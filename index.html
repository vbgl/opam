<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
  <title>Coq Package Index | The Coq Proof Assistant</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="shortcut icon" href="/files/coq_favicon.ico" type="image/x-icon" />
  <link type="text/css" rel="stylesheet" media="all" href="/styles/barron/style.css" />
  
<link rel="stylesheet" type="text/css" href="styles/barron/style.css"/>
<link rel="stylesheet" type="text/css" href="index-style.css"/>

</head>

<body>
  <div id="container">

    <div id="header">
      <div id="nav">
        <ul class="links">
          <li><a href="/">Home</a></li>
          <li><a href="/about-coq">About Coq</a></li>
          <li><a href="/download">Get Coq</a></li>
          <li><a href="/documentation">Documentation</a></li>
          <li><a href="/community">Community</a></li>
          <li><a href="/consortium">Consortium</a></li>
          <li><a href="/news">News</a></li>
        </ul>
      </div><!-- /nav -->
      <a href="https://github.com/coq/coq">
          <img style="position: absolute; top: 0; right: 0; border: 0;"
               src="/files/forkme.png"
               alt="Fork me on GitHub" />
      </a>
      <div id="logo-wrapper">
        <div id="logo">
          <a href="/" title="Home"><img src="/files/barron_logo.png" alt="Home" /></a>
        </div>
        <h1 class="site-name"><a href="/" title="Home">The Coq Proof Assistant</a></h1>
      </div><!-- /logo-wrapper-->
    </div><!-- /header-->

<div id="content">
<div class="breadcrumb">

<a href="/">Home</a>
</div>
<h2 class="page-title">Coq Package Index</h2>
<div class="node">


<div class="content">



<div id="filters">

  <div class="framework">
  <div class="frameworklabel" style="color:black;font-weight:bold">
    Active filters
  </div>
  <div class="frameworkcontent">
  <input type="text" id="custom-filter" onkeyup="update_filter()" autofocus>
  <div id="f-selected">
  </div>
  </div>
  </div>

  <div class="framework">
  <div class="frameworklabel" style="color:black;font-weight:bold">
    Available suites
  </div>
  <div class="frameworkcontent">
  <div id="f-suites"> <!-- filled in by js --> </div>
  </div>
  </div>

  <div class="framework">
  <div class="frameworklabel" style="color:black;font-weight:bold">
    Available categories
  </div>
  <div class="frameworkcontent">
  <div id="f-categories"> <!-- filled in by js --> </div>
  </div>
  </div>

  <div class="framework">
  <div class="frameworklabel" style="color:black;font-weight:bold">
    Available Keywords
  </div>
  <div class="frameworkcontent">
  <div id="f-keywords"> <!-- filled in by js --> </div>
  <div class="clear"> <!-- stop floating contents --> </div>
  </div>
  </div>

</div>

<div id="packages">
  <div class="frameworkcontent">
   <table>
  <tbody id="data">
   <tr class="package"><td> <a href="https://github.com/coq-contribs/otway-rees"><h3 class="name">coq-otway-rees</h3></a><p class="description">Otway-Rees cryptographic protocol.

A description and a proof of correctness for
the Otway-Rees cryptographic protocol, usually used as an example for
formalisation of such protocols.
</p><div class="metadata"><div class="authors">authors: <span class="author">Dominique Bolignano</span><span class="author">Valérie Ménissier-Morain</span><span class="author">Dominique Bolignano and Valérie Ménissier-Morain</span></div><div class="categories">categories: <span class="category">Computer Science/Concurrent Systems and Protocols/Correctness of specific protocols</span><span class="category"> Computer Science/Concurrent Systems and Protocols/Correctness of specific protocols</span></div><div class="keywords">keywords: <span class="keyword">otway rees</span><span class="keyword">protocols</span><span class="keyword">cryptography</span><span class="keyword"> Otway-Rees</span><span class="keyword"> protocols</span><span class="keyword"> cryptography</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://equations-fpred.gforge.inria.fr/"><h3 class="name">coq-equations-fpred</h3></a><p class="description">A formalization of Predicative System F, including a computable normalization function.
</p><div class="metadata"><div class="versions">version: <span class="version">1.0.1.dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs://github.com/coq-contribs/intuitionistic-nuprl"><h3 class="name">coq-intuitionistic-nuprl</h3></a><p class="description">An Impredicative Model of Nuprl's Constructive Type Theory

http://www.nuprl.org/html/Nuprl2Coq/

This library formalizes Nuprl's Constructive Type Theory (CTT) as of
2015.  CTT is an extensional type theory originally inspired by
Martin-Lof's extensional type theory, and that has since then been
extended with several new types such as: intersection types, union
types, image types, partial types, set types, quotient types, partial
equivalence relation (per) types, simulation and bisimulation types,
an atom type, and the "Base" type.

Our formalization includes a definition of Nuprl's computation system,
a definition of Howe's computational equivalence relation and a proof
that it is a congruence, an impredicative definition of Nuprl's type
system using Allen's PER semantics (using Prop's impredicativity, we
can formalize Nuprl's infinite hierarchy of universes), definitions of
most (but not all) of Nuprl's inference rules and proofs that these
rules are valid w.r.t. Allen's PER semantics, and a proof of Nuprl's
consistency.

In addition to the standard introduction and elimination rules for
Nuprl's types, we have also proved several Brouwerian rules.  Our
computation system also contains: (1) free choice sequences that we
used to prove Bar Induction rules; (2) named exceptions and a "fresh"
operator to generate fresh names, that we used to prove a continuity
rule.

More information can be found here: http://www.nuprl.org/html/Nuprl2Coq/
Feel free to send questions to the authors or to nuprl@cs.cornell.edu
</p><div class="metadata"><div class="authors">authors: <span class="author">Vincent Rahli</span><span class="author">Abhishek Anand</span><span class="author">Mark Bickford</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.6.0</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/karmaki/coq-dpdgraph"><h3 class="name">coq-dpdgraph</h3></a><p class="description">Compute dependencies between Coq objects (definitions, theorems)
and produce graphs


</p><div class="metadata"><div class="authors">authors: <span class="author">Anne Pacalet</span><span class="author">Yves Bertot</span></div><div class="versions">versions: <span class="version">0.6.2</span><span class="version">0.5.1</span><span class="version">0.6</span><span class="version">0.4</span><span class="version">0.6.3</span><span class="version">0.6.1</span><span class="version">0.5</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/ipc"><h3 class="name">coq-ipc</h3></a><p class="description">Intuitionistic Propositional Checker.

This development treats proof search in intuitionistic propositional logic,
a fragment of any constructive type theory. We present new and more
efficient decision procedures for intuitionistic propositional
logic. They themselves are given by (non-formal) constructive proofs.
We take one of them to demonstrate that constructive type theory can
be used in practice to develop a real, efficient, but error-free proof
searcher. This was done by formally proving the decidability of
intuitionistic propositional logic in Coq; the proof searcher was
automatically extracted.
</p><div class="metadata"><div class="authors">author: <span class="author">Klaus Weich</span></div><div class="categories">categories: <span class="category">Mathematics/Logic/Foundations</span><span class="category">Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span><span class="category">Miscellaneous/Extracted Programs/Decision procedures</span><span class="category"> Mathematics/Logic/Foundations</span><span class="category"> Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span><span class="category"> Miscellaneous/Extracted Programs/Decision procedures</span></div><div class="keywords">keywords: <span class="keyword">intuitionistic logic</span><span class="keyword">proof search</span><span class="keyword">proof as programs</span><span class="keyword">correct by construction</span><span class="keyword">program verification</span><span class="keyword">program extraction</span><span class="keyword"> intuitionistic logic </span><span class="keyword"> proof search </span><span class="keyword"> proof-as-programs </span><span class="keyword"> correct-by-construction </span><span class="keyword"> program verification</span><span class="keyword"> program extraction</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://ankitku.github.io/posts/2016-10-30-Mechanizing-Metatheory-of-TAL-0.html"><h3 class="name">coq-tal0</h3></a><p class="description">Based on the paper "Typed Assembly Language" by Greg Morrisett , TAL-0 is the design of a RISC-style typed assembly language which focuses on control-flow safety. This package provides a mechanized metatheory, particularly a machine checked proof of soundness of the TAL-0 type system as proposed by the author in section 4.2.10 of the book Advanced Topics in Types and Programming Languages.
</p><div class="metadata"><div class="authors">author: <span class="author">Ankit Kumar</span></div><div class="versions">version: <span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://gitlab.inria.fr/charguer/cfml"><h3 class="name">coq-cfml</h3></a><p class="description">A tool for proving OCaml programs in Separation Logic

CFML is a tool for carrying out proofs of correctness of OCaml programs with
respect to specifications expressed in higher-order Separation Logic.

CFML consists of two parts:

- a tool, implemented in OCaml, parses OCaml source code and generates Coq
  files that contain characteristic formulae, that is, logical descriptions
  of the behavior of the OCaml code.

- a Coq library exports definitions, lemmas, and tactics that are used
  to reason inside Coq about the code. In short, these tactics allow
  the reasoning rules of Separation Logic to be applied to the OCaml code.
</p><div class="metadata"><div class="versions">versions: <span class="version">20180525</span><span class="version">20181201</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/huffman"><h3 class="name">coq-huffman</h3></a><p class="description">A correctness proof of Huffman algorithm.

This directory contains the proof of correctness of Huffman algorithm
as described in:

David A. Huffman,
"A Method for the Construction of Minimum-Redundancy Codes,"
Proc. IRE, pp. 1098-1101, September 1952.
</p><div class="metadata"><div class="authors">author: <span class="author">Laurent Théry</span></div><div class="dates">date: <span class="date">2003-10</span><span class="date"> 2003-10</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span><span class="category">Miscellaneous/Extracted Programs/Combinatorics</span><span class="category"> Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span><span class="category"> Miscellaneous/Extracted Programs/Combinatorics</span></div><div class="keywords">keywords: <span class="keyword">data compression</span><span class="keyword">code</span><span class="keyword">huffman tree</span><span class="keyword"> Data Compression</span><span class="keyword"> Code</span><span class="keyword"> Huffman Tree</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/coq-in-coq"><h3 class="name">coq-coq-in-coq</h3></a><p class="description">A formalisation of the Calculus of Construction.
</p><div class="metadata"><div class="authors">author: <span class="author">Bruno Barras</span></div><div class="categories">categories: <span class="category">Mathematics/Logic/Type theory</span><span class="category">Miscellaneous/Extracted Programs/Type checking unification and normalization</span></div><div class="keywords">keyword: <span class="keyword">calculus of constructions</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/euclidean-geometry"><h3 class="name">coq-euclidean-geometry</h3></a><p class="description">Basis of the Euclid's plane geometry.

This is a more recent version of the basis of Euclid's plane geometry, the previous version was the contribution intitled RulerCompassGeometry.
The plane geometry is defined as a set of points, with two predicates : Clokwise for the orientation and Equidistant for the metric and three constructors, Ruler for the lines, Compass for the circles and Intersection for the points.
For using it, we suggest to compile the files the name of which begin by a capital letter and a number from A1 to N7 in the lexicographic order and to keep modifiable the files of tacics (from Tactic1 to Tactic4) and the files of examples (Hilbert and Bolyai).
</p><div class="metadata"><div class="authors">author: <span class="author">Jean Duprat</span></div><div class="categories">categories: <span class="category">Mathematics/Geometry/General</span><span class="category"> Mathematics/Geometry/General</span></div><div class="keywords">keywords: <span class="keyword">plane geometry</span><span class="keyword">euclid</span><span class="keyword">ruler and compass geometry</span><span class="keyword"> plane geometry</span><span class="keyword"> Euclid</span><span class="keyword"> ruler and compass</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/high-school-geometry"><h3 class="name">coq-high-school-geometry</h3></a><p class="description">Geometry for French high-school.

This library is dedicated to high-shool geometry teaching.
The axiomatisation for affine euclidean space is in a non analytic setting.
</p><div class="metadata"><div class="authors">author: <span class="author">Frédérique Guilhot</span></div><div class="dates">date: <span class="date">2004-01</span><span class="date"> 2004-01</span></div><div class="categories">categories: <span class="category">Mathematics/Geometry/General</span><span class="category"> Mathematics/Geometry/General</span></div><div class="keywords">keywords: <span class="keyword">geometry</span><span class="keyword">teaching</span><span class="keyword">high school</span><span class="keyword"> geometry</span><span class="keyword"> teaching</span><span class="keyword"> high-school</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">1.0.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/continuations"><h3 class="name">coq-continuations</h3></a><p class="description">A toolkit to reason with programs raising exceptions.

We show a way of developing correct functionnal programs
raising exceptions. This is made possible using a Continuation
Passing Style translation, see the contribution "exceptions" from
P. Casteran at Bordeaux. Things are made easier and more modular using
some general definitions.
</p><div class="metadata"><div class="authors">author: <span class="author">Jean-François Monin</span></div><div class="categories">categories: <span class="category">Computer Science/Semantics and Compilation/Semantics</span><span class="category">Miscellaneous/Extracted Programs/Combinatorics</span><span class="category"> Computer Science/Semantics and Compilation/Semantics</span><span class="category"> Miscellaneous/Extracted Programs/Combinatorics</span></div><div class="keywords">keywords: <span class="keyword">exceptions</span><span class="keyword">monads</span><span class="keyword">continuations</span><span class="keyword">cps</span><span class="keyword"> exceptions</span><span class="keyword"> monads</span><span class="keyword"> continuations</span><span class="keyword"> cps</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/railroad-crossing"><h3 class="name">coq-railroad-crossing</h3></a><p class="description">The Railroad Crossing Example.

This library present the specification and verification of
one real time system: the Railroad Crossing Problem, which has been
proposed as a benchmark for the comparison of real-time formalisms. We
specify the system using timed automatas (timed graphs) with discrete
time and we prove invariants, the system safety property and the NonZeno
property, using the logics CTL and TCTL.
</p><div class="metadata"><div class="authors">authors: <span class="author">Carlos Daniel Luna</span><span class="author">Carlos Daniel Luna [http://www.fing.edu.uy/~cluna]</span></div><div class="dates">date: <span class="date">February-March 2000</span><span class="date"> February-March 2000</span></div><div class="categories">categories: <span class="category">Computer Science/Concurrent Systems and Protocols/Correctness of specific protocols</span><span class="category"> Computer Science/Concurrent Systems and Protocols/Correctness of specific protocols</span></div><div class="keywords">keywords: <span class="keyword">ctl</span><span class="keyword">tctl</span><span class="keyword">real time systems</span><span class="keyword">timed automatas</span><span class="keyword">safety</span><span class="keyword">concurrency</span><span class="keyword">properties</span><span class="keyword">invariants</span><span class="keyword">nonzeno</span><span class="keyword">discrete time</span><span class="keyword"> CTL</span><span class="keyword"> TCTL</span><span class="keyword"> Real Time Systems</span><span class="keyword"> Timed Automatas</span><span class="keyword"> Safety</span><span class="keyword"> Concurrency Properties</span><span class="keyword"> Invariants</span><span class="keyword"> NonZeno</span><span class="keyword"> Discrete Time.</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/dictionaries"><h3 class="name">coq-dictionaries</h3></a><p class="description">Dictionaries (with modules).

This file contains a specification for dictionaries, and
an implementation using binary search trees. Coq's module system,
with module types and functors, is heavily used. It can be considered
as a certified version of an example proposed by Paulson in Standard ML.
A detailed description (in French) can be found in the chapter 11 of
The Coq'Art, the book written by Yves Bertot and Pierre Castéran
(please follow the link http://coq.inria.fr/doc-eng.html )
</p><div class="metadata"><div class="authors">author: <span class="author">Pierre Castéran</span></div><div class="dates">date: <span class="date">2003-02-6</span><span class="date"> 2003-02-6</span></div><div class="categories">categories: <span class="category">Computer Science/Data Types and Data Structures</span><span class="category">Miscellaneous/Extracted Programs/Data structures</span><span class="category"> Computer Science/Data Types and Data Structures</span><span class="category"> Miscellaneous/Extracted Programs/Data structures</span></div><div class="keywords">keywords: <span class="keyword">modules  functors search trees</span><span class="keyword"> modules  functors search-trees</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/pi-calc"><h3 class="name">coq-pi-calc</h3></a><p class="description">Pi-calculus in Coq.

This is a HOAS-based encoding of the pi-calculus (as originally
conceived by Milner, Parrow and Walker in "A Calculus of Mobile
Processes" Parts I-II, Information and Computation n. 100)
together with the formal verification of a large part of the
metatheory of Strong Late Bisimilarity.
</p><div class="metadata"><div class="authors">author: <span class="author">Ivan Scagnetto</span></div><div class="dates">date: <span class="date">1998-07</span><span class="date"> 1998-07</span></div><div class="categories">categories: <span class="category">Computer Science/Concurrent Systems and Protocols/Theory of concurrent systems</span><span class="category"> Computer Science/Concurrent Systems and Protocols/Theory of concurrent systems</span></div><div class="keywords">keywords: <span class="keyword">process algebra</span><span class="keyword">pi calculus</span><span class="keyword">concurrency</span><span class="keyword">formal verification</span><span class="keyword">higher order syntax</span><span class="keyword"> process algebras</span><span class="keyword"> pi-calculus</span><span class="keyword"> concurrency</span><span class="keyword"> formal verification</span><span class="keyword"> higher order syntax</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/tait"><h3 class="name">coq-tait</h3></a><p class="description">A normalization proof a la Tait for simply-typed lambda-calculus.

This is a formalization of Berger's TLCA'93 paper, with complete proofs
of the axioms and an extraction of a normalization program close to N.B.E.
</p><div class="metadata"><div class="authors">authors: <span class="author">Helmut Schwichtenberg</span><span class="author">Pierre Letouzey</span></div><div class="dates">date: <span class="date">2004</span><span class="date"> 2004</span></div><div class="categories">categories: <span class="category">Mathematics/Logic/Type theory</span><span class="category">Computer Science/Lambda Calculi</span><span class="category">Miscellaneous/Extracted Programs/Type checking unification and normalization</span><span class="category"> Mathematics/Logic/Type theory</span><span class="category"> Computer Science/Lambda Calculi</span><span class="category"> Miscellaneous/Extracted Programs/Type checking unification and normalization</span></div><div class="keywords">keywords: <span class="keyword">normalization</span><span class="keyword">lambda calculus</span><span class="keyword">extraction</span><span class="keyword">tait proof</span><span class="keyword">normalization by evalution</span><span class="keyword">type theory</span><span class="keyword"> Normalization</span><span class="keyword"> Lambda-calculus</span><span class="keyword"> Extraction</span><span class="keyword"> Tait proof</span><span class="keyword"> normalization by evalution</span><span class="keyword"> type theory</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/coq-function-ninjas"><h3 class="name">coq-function-ninjas</h3></a><p class="description">Simple functional combinators.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">version: <span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://www.maximedenes.fr/content/coqeal-coq-effective-algebra-library"><h3 class="name">coq-coqeal-theory</h3></a><p class="description">The theory needed by the refinement framework library.
</p><div class="metadata"><div class="versions">version: <span class="version">0.9.1</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/coq-list-plus"><h3 class="name">coq-list-plus</h3></a><p class="description">More functions on lists.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">versions: <span class="version">1.0.0</span><span class="version">1.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://math-classes.org/"><h3 class="name">coq-math-classes</h3></a><p class="description">A library of abstract interfaces for mathematical structures in Coq.

We have been working on a new set of foundational interfaces for formalized constructive mathematics in Coq, heavily based on Coq's new type classes, used in a systematic way in order to achieve:
* elegant and mathematically sound abstract interfaces for algebraic and numeric structures up to and including rationals (with practical use of universal algebra and category theory);
* a very flexible purely predicate-based representation of algebraic structures that makes sharing, multiple inheritance, and derived inheritance, all trivial;
* clean expression terms that neither refer to proofs nor require deeply nested record projections;
* fluent rewriting;
* easy and flexible replacement and specialization of data representations and operations with more efficient versions;
* ordinary mathematical notation and overloaded names not reliant on Coq's notation scopes.
</p><div class="metadata"><div class="authors">authors: <span class="author">Eelis van der Weegen</span><span class="author">Bas Spitters</span><span class="author">Robbert Krebbers</span></div><div class="categories">category: <span class="category">Mathematics/Algebra</span></div><div class="keywords">keywords: <span class="keyword">type classes</span><span class="keyword">algebraic and numeric structures</span><span class="keyword">universal algebra</span><span class="keyword">category theory</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.0.3</span><span class="version">1.0.4</span><span class="version">1.0.6</span><span class="version">1.0.5</span><span class="version">1.0.7</span><span class="version">8.7.dev</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.8.1</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/ruler-compass-geometry"><h3 class="name">coq-ruler-compass-geometry</h3></a><p class="description">Ruler and compass geometry axiomatization.

This library contains an axiomatization of the ruler and
compass euclidian geometry. Files A1 to A6 contain the axioms and the
basic constructions. The other files build the proof that this
axiomatization induces the whole plane geometry except the continuity
axiom. For that the proofs of the Hilbert's axioms conclude this work in
the files E1 to E5.
</p><div class="metadata"><div class="authors">author: <span class="author">Jean Duprat</span></div><div class="dates">date: <span class="date">2007-11</span><span class="date"> 2007-11</span></div><div class="categories">categories: <span class="category">Mathematics/Geometry/General</span><span class="category"> Mathematics/Geometry/General</span></div><div class="keywords">keywords: <span class="keyword">geometry</span><span class="keyword">plane geometry</span><span class="keyword">ruler and compass geometry</span><span class="keyword">euclidean geometry</span><span class="keyword">hilbert's axioms</span><span class="keyword"> geometry</span><span class="keyword"> plane geometry</span><span class="keyword"> ruler and compass geometry</span><span class="keyword"> Euclidian geometry</span><span class="keyword"> Hilbert's axioms</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/square-matrices"><h3 class="name">coq-square-matrices</h3></a><p class="description">From Fast Exponentiation to Square Matrices.

This development is a formalization of Chris Okasaki's article
``From Fast Exponentiation to Square Matrices: An Adventure in Types''
</p><div class="metadata"><div class="authors">author: <span class="author">Jean-Christophe Filliâtre</span></div><div class="categories">categories: <span class="category">Mathematics/Algebra</span><span class="category"> Mathematics/Algebra</span></div><div class="keywords">keywords: <span class="keyword">exponentiation</span><span class="keyword">vectors</span><span class="keyword">matrices</span><span class="keyword">polymorphic recursion</span><span class="keyword">nested datatypes</span><span class="keyword"> exponentiation</span><span class="keyword"> vectors</span><span class="keyword"> matrices</span><span class="keyword"> polymorphic recursion</span><span class="keyword"> nested datatypes</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/uwplse/StructTact"><h3 class="name">coq-struct-tact</h3></a><p class="description">StructTact is a Coq library of "structural tactics" as well as Coq libraries containing lemmas about lists and finite types that use the tactics library.
</p><div class="metadata"><div class="authors">authors: <span class="author">Ryan Doenges</span><span class="author">Karl Palmskog</span><span class="author">Keith Simmons</span><span class="author">James Wilcox</span><span class="author">Doug Woos</span></div><div class="keywords">keyword: <span class="keyword">proof automation</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.7.dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/Mtac2/Mtac2"><h3 class="name">coq-mtac2</h3></a><p class="description">Mtac2: Typed Tactics for Coq
</p><div class="metadata"><div class="authors">authors: <span class="author">Beta Ziliani</span><span class="author">Jan-Oliver Kaiser</span><span class="author">Robbert Krebbers</span><span class="author">Yann Régis-Gianas</span><span class="author">Derek Dreyer</span></div><div class="versions">versions: <span class="version">1.0.1+8.8</span><span class="version">1.0.0+8.7</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/strub/elliptic-curves-ssr"><h3 class="name">coq-ssr-elliptic-curves</h3></a><p class="description">A Formal Library about Elliptic Curves for the Mathematical Components Library.
</p><div class="metadata"><div class="authors">authors: <span class="author">Evmorfia-Iro Bartzia</span><span class="author">Pierre-Yves Strub</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.6.dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/schroeder"><h3 class="name">coq-schroeder</h3></a><p class="description">The Theorem of Schroeder-Bernstein.

Fraenkel's proof of Schroeder-Bernstein theorem on decidable sets
is formalized in a constructive variant of set theory based on
stratified universes (the one defined in the Ensemble library).
The informal proof can be found for instance in "Axiomatic Set Theory"
from P. Suppes.
</p><div class="metadata"><div class="authors">author: <span class="author">Hugo Herbelin</span></div><div class="categories">category: <span class="category">Mathematics/Logic/Set theory</span></div><div class="keywords">keywords: <span class="keyword">schroeder bernstein</span><span class="keyword">set theory</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/gmalecha/coq-extensible-records"><h3 class="name">coq-extensible-records</h3></a><p class="description">Definitional (canonical) extensible records in Coq with string keys and arbitrary (non-dependent) types.</p><div class="metadata"><div class="authors">author: <span class="author">Gregory Malecha</span></div><div class="versions">versions: <span class="version">1.2.0</span><span class="version">1.0.0</span><span class="version">1.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs//coq:containers/coq:containers"><h3 class="name">coq-containers</h3></a><p class="description">Containers: a typeclass-based library of finite sets/maps.

This is a reimplementation of the FSets/FMaps library from the standard library, using typeclasses. See tests files for usage. A new vernacular command is provided by Generate.v and the plugin to automatically generate ordered types for user-defined inductive types.
</p><div class="metadata"><div class="authors">author: <span class="author">Stéphane Lescuyer</span></div><div class="categories">categories: <span class="category">Computer Science/Data Types and Data Structures</span><span class="category"> Computer Science/Data Types and Data Structures</span></div><div class="keywords">keywords: <span class="keyword">data structures</span><span class="keyword">type classes</span><span class="keyword"> data structures</span><span class="keyword"> type classes</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/rational"><h3 class="name">coq-rational</h3></a><p class="description">A definition of rational numbers.

Definition of integers as the usual symetric
completion of a semi-group and of rational numbers as the product of
integers and strictly positive integers quotiented by the usual relation.
This implementation assumes two sets of axioms allowing to define
quotient types and subset types. These sets of axioms should be
proved coherent by mixing up the deliverable model and the setoid model
(both are presented in Martin Hofmann' thesis).
</p><div class="metadata"><div class="authors">author: <span class="author">Samuel Boutin</span></div><div class="categories">categories: <span class="category">Mathematics/Arithmetic and Number Theory/Rational numbers</span><span class="category"> Mathematics/Arithmetic and Number Theory/Rational numbers</span></div><div class="keywords">keywords: <span class="keyword">integers</span><span class="keyword">rational numbers</span><span class="keyword">quotient types</span><span class="keyword">subset types</span><span class="keyword"> Integers</span><span class="keyword"> rational numbers</span><span class="keyword"> quotient types</span><span class="keyword"> subset types</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://iris-project.org/"><h3 class="name">coq-iris</h3></a><p class="description">This is the Coq development of the Iris Project.
</p><div class="metadata"><div class="versions">versions: <span class="version">3.0.0</span><span class="version">3.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/reflexive-first-order"><h3 class="name">coq-reflexive-first-order</h3></a><p class="description">Reflexive first-order proof interpreter.

This contribution is a package which can be used to interpret firstorder
proofs provided by an external theorem prover, using computationnal
reflexion.
</p><div class="metadata"><div class="authors">author: <span class="author">Pierre Corbineau</span></div><div class="dates">date: <span class="date">2005-05</span><span class="date"> 2005-05</span></div><div class="categories">categories: <span class="category">Miscellaneous/Coq Extensions</span><span class="category"> Miscellaneous/Coq Extensions</span></div><div class="keywords">keywords: <span class="keyword">computationnal reflection</span><span class="keyword">interpretation</span><span class="keyword">first order logic</span><span class="keyword">equational reasoning</span><span class="keyword"> computationnal reflection</span><span class="keyword"> interpretation</span><span class="keyword"> first-order logic</span><span class="keyword"> equational reasoning</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/founify"><h3 class="name">coq-founify</h3></a><p class="description">Correctness and extraction of the unification algorithm.

A notion of terms based on symbols without fixed arities is defined
and an extended unification problem is proved solvable on these terms.
An algorithm, close from Robinson algorithm, can be extracted from the
proof.
</p><div class="metadata"><div class="authors">author: <span class="author">Jocelyne Rouyer</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span><span class="category">Miscellaneous/Extracted Programs/Type checking unification and normalization</span><span class="category"> Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span><span class="category"> Miscellaneous/Extracted Programs/Type checking unification and normalization</span></div><div class="keywords">keywords: <span class="keyword">first order unification</span><span class="keyword">robinson</span><span class="keyword"> First-order Unification</span><span class="keyword"> Robinson</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/circuits"><h3 class="name">coq-circuits</h3></a><p class="description">Some proofs of hardware (adder, multiplier, memory block instruction).

definition and proof of a combinatorial adder, a
sequential multiplier, a memory block instruction
</p><div class="metadata"><div class="authors">author: <span class="author">Laurent Arditi</span></div><div class="categories">categories: <span class="category">Computer Science/Architecture</span><span class="category"> Computer Science/Architecture</span></div><div class="keywords">keywords: <span class="keyword">hardware verification</span><span class="keyword"> hardware verification</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/coq-opam-website"><h3 class="name">coq-opam-website</h3></a><p class="description">Generation of a Coq website for OPAM: http://coq.io/opam/ .
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">versions: <span class="version">1.3.2</span><span class="version">1.4.0</span><span class="version">1.2.0</span><span class="version">1.0.0</span><span class="version">1.3.1</span><span class="version">1.3.0</span><span class="version">1.2.1</span><span class="version">1.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/mattam82/Constructors"><h3 class="name">coq-constructors</h3></a><p class="description">An example Coq plugin, defining a tactic to get the constructors of an inductive type in a list.
</p><div class="metadata"><div class="versions">versions: <span class="version">dev</span><span class="version">1.0.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/regexp"><h3 class="name">coq-regexp</h3></a><p class="description">Regular Expression.

The Library RegExp is a Coq library for regular expression. The implementation is based on the Janusz Brzozowski's algorithm ("Derivatives of Regular Expressions", Journal of the ACM 1964).
The RegExp library satisfies the axioms of Kleene Algebra. The proofs are shown in the library.
</p><div class="metadata"><div class="authors">author: <span class="author">Takashi Miyamoto</span></div><div class="categories">category: <span class="category">Computer Science/Formal Languages Theory and Automata</span></div><div class="keywords">keywords: <span class="keyword">regular expressions</span><span class="keyword">kleene algebra</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/zorns-lemma"><h3 class="name">coq-zorns-lemma</h3></a><p class="description">Zorn's Lemma.

This library develops some basic set theory. The main purpose I had in writing it was as support for the Topology library.
</p><div class="metadata"><div class="authors">author: <span class="author">Daniel Schepler</span></div><div class="categories">category: <span class="category">Mathematics/Logic/Set theory</span></div><div class="keywords">keywords: <span class="keyword">set theory</span><span class="keyword">cardinals</span><span class="keyword">ordinals</span><span class="keyword">finite</span><span class="keyword">countable</span><span class="keyword">quotients</span><span class="keyword">well orders</span><span class="keyword">zorn's lemma</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://math-comp.github.io/math-comp/"><h3 class="name">coq-mathcomp-fingroup</h3></a><p class="description">Mathematical Components Library on finite groups

This library contains definitions and theorems about finite groups,
group quotients, group morphisms, group presentation, group action...</p><div class="metadata"><div class="authors">authors: <span class="author">Jeremy Avigad</span><span class="author">Andrea Asperti</span><span class="author">Stephane Le Roux</span><span class="author">Yves Bertot</span><span class="author">Laurence Rideau</span><span class="author">Enrico Tassi</span><span class="author">Ioana Pasca</span><span class="author">Georges Gonthier</span><span class="author">Sidi Ould Biha</span><span class="author">Cyril Cohen</span><span class="author">Francois Garillot</span><span class="author">Alexey Solovyev</span><span class="author">Russell O'Connor</span><span class="author">Laurent Théry</span><span class="author">Assia Mahboubi</span></div><div class="keywords">keywords: <span class="keyword">finite groups</span><span class="keyword">small scale reflection</span><span class="keyword">mathematical components</span><span class="keyword">odd order theorem</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.6.1</span><span class="version">1.6.2</span><span class="version">1.7.0</span><span class="version">1.6.4</span><span class="version">1.6</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-community/paramcoq"><h3 class="name">coq-paramcoq</h3></a><p class="description">Paramcoq

The plugin is still in an experimental state. It is not very user
friendly (lack of good error messages) and still contains bugs. But is
useable enough to "translate" a large chunk of standard library.
</p><div class="metadata"><div class="authors">authors: <span class="author">Chantal Keller (Inria, École polytechnique)</span><span class="author">Marc Lasson (ÉNS de Lyon)</span><span class="author">Abhishek Anand</span><span class="author">Pierre Roux</span><span class="author">Emilio Jesús Gallego Arias</span><span class="author">Cyril Cohen</span><span class="author">Matthieu Sozeau</span></div><div class="categories">categories: <span class="category">paramcoq</span><span class="category">Miscellaneous/Coq Extensions</span></div><div class="keywords">keywords: <span class="keyword">paramcoq</span><span class="keyword">parametricity</span><span class="keyword">ocaml module</span></div><div class="versions">versions: <span class="version">1.1.0</span><span class="version">1.0.5</span><span class="version">1.1.1+coq8.8</span><span class="version">1.0.6</span><span class="version">1.0.9</span><span class="version">1.1.1+coq8.7</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/tortoise-hare-algorithm"><h3 class="name">coq-tortoise-hare-algorithm</h3></a><p class="description">Tortoise and the hare algorithm.

Correctness proof of Floyd's cycle-finding algorithm, also known as
the "tortoise and the hare"-algorithm.
See http://en.wikipedia.org/wiki/Floyd's_cycle-finding_algorithm
</p><div class="metadata"><div class="authors">author: <span class="author">Jean-Christophe Filliâtre</span></div><div class="dates">date: <span class="date">2007-02</span><span class="date"> 2007-02</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span><span class="category"> Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span></div><div class="keywords">keywords: <span class="keyword">program verification</span><span class="keyword">paths</span><span class="keyword">cycle detection</span><span class="keyword">graphs</span><span class="keyword">graph theory</span><span class="keyword">finite sets</span><span class="keyword">floyd</span><span class="keyword"> program verification</span><span class="keyword"> paths</span><span class="keyword"> cycle detection</span><span class="keyword"> graphs</span><span class="keyword"> graph theory</span><span class="keyword"> finite sets</span><span class="keyword"> floyd</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/relation-algebra"><h3 class="name">coq-relation-algebra</h3></a><p class="description">A modular library about relation algebra, from idempotent semirings to residuated Kleene allegories, including a decision tactic for Kleene algebra with Tests (KAT).
</p><div class="metadata"><div class="authors">author: <span class="author">Damien Pous</span></div><div class="categories">category: <span class="category">Mathematics/Algebra</span></div><div class="keywords">keywords: <span class="keyword">relation algebra</span><span class="keyword">kleene algebra with tests</span><span class="keyword">kat</span><span class="keyword">allegories</span><span class="keyword">residuated structures</span><span class="keyword">automata</span><span class="keyword">regular expressions</span><span class="keyword">matrices</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.7</span><span class="version">1.3</span><span class="version">1.5</span><span class="version">1.6</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">1.4</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/Armael/coq-procrastination"><h3 class="name">coq-procrastination</h3></a><p class="description">A small library for collecting side conditions and deferring their proof</p><div class="metadata"><div class="authors">author: <span class="author">Armaël Guéneau</span></div><div class="versions">versions: <span class="version">1.1</span><span class="version">1.0</span><span class="version">1.2</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/io-list"><h3 class="name">coq-io-list</h3></a><p class="description">Generic functions on lists with effects.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">versions: <span class="version">1.1.0</span><span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://www.cl.cam.ac.uk/~pes20/ott/"><h3 class="name">coq-ott</h3></a><p class="description">Auxiliary library for Ott, a tool for writing definitions of programming languages and calculi
</p><div class="metadata"><div class="authors">authors: <span class="author">Peter Sewell</span><span class="author">Francesco Zappa Nardelli</span><span class="author">Scott Owens</span></div><div class="dates">date: <span class="date">2018-04-24</span></div><div class="categories">category: <span class="category">Computer Science/Semantics and Compilation/Semantics</span></div><div class="keywords">keyword: <span class="keyword">abstract syntax</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">0.26</span><span class="version">0.27</span><span class="version">8.7.dev</span><span class="version">dev</span><span class="version">0.28</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/fundamental-arithmetics"><h3 class="name">coq-fundamental-arithmetics</h3></a><p class="description">Fundamental theorems of arithmetic.
</p><div class="metadata"><div class="authors">author: <span class="author">Sébastien Briais</span></div><div class="dates">date: <span class="date">2008-02-1</span><span class="date"> 2008-02-1</span></div><div class="categories">categories: <span class="category">Mathematics/Arithmetic and Number Theory/Miscellaneous</span><span class="category"> Mathematics/Arithmetic and Number Theory/Miscellaneous</span></div><div class="keywords">keywords: <span class="keyword">arithmetic</span><span class="keyword">number theory</span><span class="keyword"> arithmetic</span><span class="keyword"> number theory</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/ails"><h3 class="name">coq-ails</h3></a><p class="description">Proof of AILS algorithm.

An aircraft trajectory modeling and analysis using the AILS
algorithm (Airborne Information for Lateral Spacing) to warn
against possible collisions.
</p><div class="metadata"><div class="authors">author: <span class="author">Olivier Desmettre</span></div><div class="dates">date: <span class="date">2002</span><span class="date"> 2002</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span><span class="category"> Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span></div><div class="keywords">keywords: <span class="keyword">ails</span><span class="keyword">aircraft</span><span class="keyword">trajectory</span><span class="keyword">conflict</span><span class="keyword">collision</span><span class="keyword"> ails</span><span class="keyword"> aircraft</span><span class="keyword"> trajectory</span><span class="keyword"> conflict</span><span class="keyword"> collision</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://homotopytypetheory.org/"><h3 class="name">coq-hott</h3></a><p class="description">The Homotopy Type Theory library.
</p><div class="metadata"><div class="authors">author: <span class="author">The Coq-HoTT Development Team</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.8.dev</span><span class="version">8.7.dev</span><span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/quicksort-complexity"><h3 class="name">coq-quicksort-complexity</h3></a><p class="description">Proofs of Quicksort's worst- and average-case complexity.

The development contains:
- a set of monads and monad transformers for measuring a (possibly nondeterministic) algorithm's use of designated operations;
- monadically expressed deterministic and nondeterministic implementations of Quicksort;
- proofs of these implementations' worst- and average case complexity.

Most of the development is documented in the TYPES 2008 paper "A Machine-Checked Proof of the Average-Case Complexity of Quicksort in Coq", available at the homepage.
</p><div class="metadata"><div class="authors">author: <span class="author">Eelis</span></div><div class="dates">date: <span class="date">2010-06</span><span class="date"> 2010-06</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span><span class="category"> Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span></div><div class="keywords">keywords: <span class="keyword">quicksort</span><span class="keyword">complexity</span><span class="keyword">average case</span><span class="keyword"> quicksort</span><span class="keyword"> complexity</span><span class="keyword"> average-case</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/group-theory"><h3 class="name">coq-group-theory</h3></a><p class="description">Elements of Group Theory.

Group Theory following the book "Group Theory" from W.R. Scott.
</p><div class="metadata"><div class="authors">author: <span class="author">Gilles Kahn</span></div><div class="categories">category: <span class="category">Mathematics/Algebra</span></div><div class="keywords">keyword: <span class="keyword">group theory</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/minic"><h3 class="name">coq-minic</h3></a><p class="description">Semantics of a subset of the C language.

This contribution defines the denotational semantics of MiniC, a
sub-set of the C language. This sub-set is sufficiently large to
contain any program generated by lustre2C.
The denotation function describing the semantics of a MiniC program
actually provides an interpreter for the program.
</p><div class="metadata"><div class="authors">authors: <span class="author">Eduardo Giménez</span><span class="author">Emmanuel Ledinot</span></div><div class="categories">category: <span class="category">Computer Science/Semantics and Compilation/Semantics</span></div><div class="keywords">keywords: <span class="keyword">denotational semantics</span><span class="keyword">compilation</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://querycert.github.io"><h3 class="name">coq-qcert</h3></a><p class="description">Verified compiler for data-centric languages
</p><div class="metadata"><div class="authors">authors: <span class="author">Josh Auerbach</span><span class="author">Martin Hirzel</span><span class="author">Louis Mandel</span><span class="author">Avi Shinnar</span><span class="author">Jerome Simeon</span></div><div class="versions">versions: <span class="version">1.0.7</span><span class="version">1.0.6</span><span class="version">1.0.5</span><span class="version">1.0.4</span><span class="version">1.2.0</span><span class="version">1.0.9</span><span class="version">1.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/idxassoc"><h3 class="name">coq-idxassoc</h3></a><p class="description">Associative Arrays.

We define the associative array (key -> value associations)
datatype as list of couples, providing definitions of standards
operations such as adding, deleting.

We introduce predicates for membership of a key and of couples.

Finally we define a search operator ("find") which returns the
value associated with a key or the "none" option (see file
Option.v which should be part of this contribution) on failure.

Lemmas we prove about these concepts were motivated by our needs
at the moment we created this file. We hope they'll suit your
needs too but anyway, feel free to communicate any wish or
remark.
</p><div class="metadata"><div class="authors">authors: <span class="author">Dominique Quatravaux</span><span class="author">Gérald Macinenti</span><span class="author">François-René Ridaux</span></div><div class="dates">date: <span class="date">2001-04</span></div><div class="categories">category: <span class="category">Computer Science/Data Types and Data Structures</span></div><div class="keywords">keywords: <span class="keyword">associative arrays</span><span class="keyword">search operator</span><span class="keyword">data structures</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/thery/twoSquare"><h3 class="name">coq-mathcomp-sum-of-two-square</h3></a><p class="description">A proof of Fermat's theorem on sum of two squares. It is the proof that uses gaussian integers. This is done in ssreflect. It contains two file :

gauss_int.v : the definition of gaussian integers

fermat2.v : the proof of Fermat's theorem

The final statement reads:

===================================================

From mathcomp
Require Import all_ssreflect.

From mathcomp.contrib.sum_of_two_square
Require Import gauss_int fermat2.
Check sum2stest.

sum2stest
     : forall n : nat,
       reflect
         (forall p : nat,
          prime p ->
          odd p -> p %| n -> odd (logn p n) -> p %% 4 = 1)
         (n \is a sum_of_two_square)

===================================================

</p><div class="metadata"><div class="versions">versions: <span class="version">1.0.1</span><span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/UniMath/UniMath"><h3 class="name">coq-unimath-category-theory</h3></a><p class="description">Aims to formalize a substantial body of mathematics using the univalent point of view. 
</p><div class="metadata"><div class="authors">author: <span class="author">The UniMath Development Team</span></div><div class="versions">version: <span class="version">0.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/orb-stab"><h3 class="name">coq-orb-stab</h3></a><p class="description">Finite orbit-stabilizer theorem.

Finite orbit-stabilizer theorem, based on Rahbar Virk's lecture notes. A large portion of the work was a simplified version of the inclusion-exclusion principle. Requires Loic Pottier's Algebra contribution, and Jasper Stein's Linear Algebra contribution.
</p><div class="metadata"><div class="authors">author: <span class="author">Robert Kam</span></div><div class="dates">date: <span class="date">2008-01-5</span><span class="date"> 2008-01-5</span></div><div class="categories">categories: <span class="category">Mathematics/Algebra</span><span class="category"> Mathematics/Algebra</span></div><div class="keywords">keywords: <span class="keyword">orbit</span><span class="keyword">stabilizer</span><span class="keyword">inclusion exclusion</span><span class="keyword"> orbit</span><span class="keyword"> stabilizer</span><span class="keyword"> inclusion-exclusion</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/coinductive-examples"><h3 class="name">coq-coinductive-examples</h3></a><p class="description">Some simple examples about co-inductive types and co-induction.

This directory containts some simple examples about
the use of co-inductive types in Coq. Directory ARITH
is about non-standard arithmetic. Directory STREAMS
contains examples about schemes, including an application
of the translation method presented in Eduardo Giménez's
article ``Codifying guarded definitions with recursive
schemes'' (LNCS no. 996).
</p><div class="metadata"><div class="authors">author: <span class="author">Eduardo Giménez</span></div><div class="categories">category: <span class="category">Miscellaneous/Coq Use Examples</span></div><div class="keywords">keywords: <span class="keyword">coinductive types</span><span class="keyword">coinduction</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/historical-examples"><h3 class="name">coq-historical-examples</h3></a><p class="description">Historical examples developed in the (pure) Calculus of Constructions .

This is a collection of historical examples developed in
system CoC that implemented Coquand's Calculus of Constructions.
Newman.v and Tarski.v originate in version 1.10, Manna.v and
Format.v are from version 4.3. Their evolution to the Calculus of
Inductive Constructions (up to Coq V6.3) are in MannaCIC.v and
FormatCIC.v. (Collection by Hugo Herbelin.)
</p><div class="metadata"><div class="authors">authors: <span class="author">Gérard Huet</span><span class="author">Christine Paulin</span></div><div class="dates">date: <span class="date"></span></div><div class="categories">categories: <span class="category">Miscellaneous/Coq Use Examples</span><span class="category"> Miscellaneous/Coq Use Examples</span></div><div class="keywords">keywords: <span class="keyword">newman's lemma</span><span class="keyword">tarski's fixpoint theorem</span><span class="keyword">line formatting</span><span class="keyword">binary search paradigm</span><span class="keyword">square root approximation</span><span class="keyword">calculus of constructions</span><span class="keyword">history of coq</span><span class="keyword"> Newman's lemma</span><span class="keyword"> Tarski's fixpoint theorem</span><span class="keyword"> line formatting</span><span class="keyword"> binary-search paradigm</span><span class="keyword"> square root approximation</span><span class="keyword"> Calculus of Constructions</span><span class="keyword"> history of Coq</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/sum-of-two-square"><h3 class="name">coq-sum-of-two-square</h3></a><p class="description">Numbers equal to the sum of two square numbers.

A proof that a number n can be written as the
sum of two square numbers if and only if each prime factor p of n
that is equal to 3 modulo 4 has its exponent in the decomposition of n
that is even.
</p><div class="metadata"><div class="authors">authors: <span class="author">Laurent Théry</span><span class="author">Laurent Thery</span></div><div class="dates">date: <span class="date">2004-12-13</span><span class="date"> 2004-12-13</span></div><div class="categories">categories: <span class="category">Mathematics/Arithmetic and Number Theory/Number theory</span><span class="category"> Mathematics/Arithmetic and Number Theory/Number theory</span></div><div class="keywords">keywords: <span class="keyword">number theory</span><span class="keyword"> number theory</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/canon-bdds"><h3 class="name">coq-canon-bdds</h3></a><p class="description">Canonicity of Binary Decision Dags.

A proof of unicity and canonicity of Binary Decision Trees and
Binary Decision Dags. This contrib contains also a development on finite sets.
</p><div class="metadata"><div class="authors">author: <span class="author">Emmanuel Ledinot</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span><span class="category">Miscellaneous/Extracted Programs/Decision procedures</span></div><div class="keywords">keywords: <span class="keyword">bdt</span><span class="keyword">finite sets</span><span class="keyword">model checking</span><span class="keyword">binary decision diagrams</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://softwarefoundations.cis.upenn.edu/"><h3 class="name">coq-sf-vfa</h3></a><p class="description">Verified Functional Algorithms (Volume 3 of Software Foundations)

Verified Functional Algorithms, shows how a variety of fundamental data structures can be mechanically verified.
</p><div class="metadata"><div class="authors">author: <span class="author">Andrew W. Appel</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/mod-red"><h3 class="name">coq-mod-red</h3></a><p class="description">Efficient Reduction of Large Integers by Small Moduli.

Fast reduction of integers by moduli up to 2^(w-1), where w is a processor's word size.
</p><div class="metadata"><div class="authors">author: <span class="author">Luc Rutten</span></div><div class="dates">date: <span class="date">December 2007; Updated in April 2009</span><span class="date"> 2007-12; Updated in April 2009</span></div><div class="categories">categories: <span class="category">Mathematics/Arithmetic and Number Theory/Miscellaneous</span><span class="category"> Mathematics/Arithmetic and Number Theory/Miscellaneous</span></div><div class="keywords">keywords: <span class="keyword">algorithms</span><span class="keyword">performance</span><span class="keyword">computer arithmetic</span><span class="keyword">modular reduction</span><span class="keyword">optimization</span><span class="keyword"> Algorithms</span><span class="keyword"> Performance</span><span class="keyword"> Computer Arithmetic</span><span class="keyword"> Modular Reduction</span><span class="keyword"> Optimization</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/algebra"><h3 class="name">coq-algebra</h3></a><p class="description">Basics notions of algebra.
</p><div class="metadata"><div class="authors">authors: <span class="author">Loïc Pottier</span><span class="author">Loïc Pottier [http://www-sop.inria.fr/croap/personnel/Loic.Pottier/home.html]</span></div><div class="dates">date: <span class="date">1999-03</span><span class="date"> 1999-03</span></div><div class="categories">categories: <span class="category">Mathematics/Algebra</span><span class="category"> Mathematics/Algebra</span></div><div class="keywords">keywords: <span class="keyword">algebra</span><span class="keyword"> algebra</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/functions-in-zfc"><h3 class="name">coq-functions-in-zfc</h3></a><p class="description">Functions in classical ZFC.

This mostly repeats Guillaume Alexandre's contribution `zf',
but in classical logic and with a different proof style. We start with a
simple axiomatization of some flavor of ZFC (for example Werner's
implementation of ZFC should provide a model).
We develop some very basic things like pairs, functions, and a little
bit about natural numbers, following the standard classical path.
</p><div class="metadata"><div class="authors">author: <span class="author">Carlos Simpson</span></div><div class="dates">date: <span class="date">2001-04</span><span class="date"> April 2001</span></div><div class="categories">categories: <span class="category">Mathematics/Logic/Set theory</span><span class="category"> Mathematics/Logic/Set theory</span></div><div class="keywords">keywords: <span class="keyword">set theory</span><span class="keyword">zermelo fraenkel</span><span class="keyword">functions</span><span class="keyword"> Set Theory</span><span class="keyword"> Zermelo-Fraenkel</span><span class="keyword"> functions</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/Lysxia/coq-simple-io"><h3 class="name">coq-simple-io</h3></a><p class="description">IO monad for Coq

This library provides tools to implement IO programs directly in Coq, in a
similar style to Haskell. Facilities for formal verification are not included.

IO is defined as a parameter with a purely functional interface in Coq,
to be extracted to OCaml.

Some wrappers for the basic types and functions in the OCaml Pervasives module
are provided. Users are free to define their own APIs on top of this IO type.
</p><div class="metadata"><div class="dates">date: <span class="date">2018-07-28</span></div><div class="keywords">keywords: <span class="keyword">extraction</span><span class="keyword">effects</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">0.1</span><span class="version">0.2</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/QuickChick/QuickChick"><h3 class="name">coq-quickchick</h3></a><p class="description">QuickChick is a random property-based testing library for Coq.
</p><div class="metadata"><div class="authors">authors: <span class="author">Leonidas Lampropoulos</span><span class="author">Zoe Paraskevopoulou</span><span class="author">Maxime Denes</span><span class="author">Catalin Hritcu</span><span class="author">Benjamin Pierce</span><span class="author">Arthur Azevedo de Amorim</span><span class="author">Antal Spector-Zabusky</span><span class="author">Li-Yao Xia</span><span class="author">Yishuai Li</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.0.0</span><span class="version">1.0.2</span><span class="version">8.8.dev</span><span class="version">1.0.1</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://coqprime.gforge.inria.fr/"><h3 class="name">coq-coqprime</h3></a><p class="description">Certifying prime numbers in Coq
</p><div class="metadata"><div class="authors">author: <span class="author">Laurent Théry</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.0.2</span><span class="version">1.0.1</span><span class="version">1.0.0</span><span class="version">1.0.3</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/cantor"><h3 class="name">coq-cantor</h3></a><p class="description">On Ordinal Notations .

This contribution contains data structures for ordinals
less than Gamma0 under Cantor and Veblen normal
forms. Well-foundedness is established thanks to RPO with status for
generic terms. This contribution also includes termination proofs of
Hydra battles and Goodstein sequences as well as a computation of the
length of the Goodstein sequence starting from 4 in base 2.

This work is supported by INRIA-Futurs (Logical project-team), CNRS
and the French ANR via the A3PAT project (http://www3.iie.cnam.fr/~urbain/a3pat/).
</p><div class="metadata"><div class="authors">authors: <span class="author">Évelyne Contejean</span><span class="author">Pierre Castéran</span></div><div class="dates">date: <span class="date">2006-05-22</span><span class="date"> 2006-05-22</span></div><div class="categories">categories: <span class="category">Mathematics/Arithmetic and Number Theory/Number theory</span><span class="category"> Mathematics/Logic/See also</span><span class="category"> Mathematics/Arithmetic and Number Theory/Number theory</span></div><div class="keywords">keywords: <span class="keyword">ordinals</span><span class="keyword">well foundedness</span><span class="keyword">termination</span><span class="keyword">rpo</span><span class="keyword">goodstein sequences</span><span class="keyword"> ordinals</span><span class="keyword"> well-foundedness</span><span class="keyword"> termination</span><span class="keyword"> rpo</span><span class="keyword"> Goodstein sequences</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/legacy-field"><h3 class="name">coq-legacy-field</h3></a><p class="description">The former implementation of the field tactic.
</p><div class="metadata"><div class="authors">authors: <span class="author">David Delahaye</span><span class="author">Micaela Mayero</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://sourcesup.renater.fr/validsdp/"><h3 class="name">coq-libvalidsdp</h3></a><p class="description">LibValidSDP

LibValidSDP is a library for the Coq formal proof assistant. It provides
results mostly about rounding errors in the Cholesky decomposition algorithm
used in the ValidSDP library which itself implements Coq tactics to prove
multivariate inequalities using SDP solvers.

Once installed, the following modules can be imported :
From libValidSDP Require Import Rstruct.v misc.v real_matrix.v bounded.v float_spec.v fsum.v fcmsum.v binary64.v cholesky.v float_infnan_spec.v binary64_infnan.v cholesky_infnan.v flx64.v zulp.v coqinterval_infnan.v.
</p><div class="metadata"><div class="authors">authors: <span class="author">Pierre Roux</span><span class="author">Érik Martin-Dorel</span></div><div class="categories">categories: <span class="category">libValidSDP</span><span class="category">Miscellaneous/Coq Extensions</span></div><div class="keywords">keywords: <span class="keyword">libValidSDP</span><span class="keyword">ValidSDP</span><span class="keyword">floating-point arithmetic</span><span class="keyword">Cholesky decomposition</span></div><div class="versions">version: <span class="version">0.5</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/bmsherman/topology"><h3 class="name">coq-formal-topology</h3></a><p class="description">A programming language for topology and probability in Coq.
</p><div class="metadata"><div class="authors">author: <span class="author">Ben Sherman</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.dev</span><span class="version">8.6.dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/persistent-union-find"><h3 class="name">coq-persistent-union-find</h3></a><p class="description">Persistent Union Find.

Correctness proof of the Ocaml implementation of a persistent union-find
data structure. See http://www.lri.fr/~filliatr/puf/ for more details.
</p><div class="metadata"><div class="authors">author: <span class="author">Jean-Christophe Filliâtre</span></div><div class="categories">category: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span></div><div class="keywords">keywords: <span class="keyword">program verification</span><span class="keyword">union find</span><span class="keyword">data structures</span><span class="keyword">tarjan</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/streams"><h3 class="name">coq-streams</h3></a><p class="description">Specification of Eratosthene Sieve .

Proof of Eratosthene Sieve formalised using streams
encoded as greatest fixpoints. See paper:
@InProceedings{LePa94,
author = "F. Leclerc and C. Paulin-Mohring",
title = "Programming with Streams in {Coq}. A case study : The Sieve of Eratosthenes",
editor = "H. Barendregt and T. Nipkow",
volume = 806,
series = "LNCS",
booktitle = "{Types for Proofs and Programs, Types' 93}",
year = 1994,
publisher = "Springer-Verlag"
}
</p><div class="metadata"><div class="authors">authors: <span class="author">François Leclerc</span><span class="author">Christine Paulin-Mohring</span><span class="author">François Leclerc, Christine Paulin-Mohring</span></div><div class="categories">categories: <span class="category">Mathematics/Arithmetic and Number Theory/Number theory</span><span class="category"> Mathematics/Arithmetic and Number Theory/Number theory</span></div><div class="keywords">keywords: <span class="keyword">streams</span><span class="keyword">eratosthene sieve</span><span class="keyword">prime numbers</span><span class="keyword">number theory</span><span class="keyword">primality</span><span class="keyword"> Streams</span><span class="keyword"> Eratosthene Sieve</span><span class="keyword"> prime numbers</span><span class="keyword"> number theory</span><span class="keyword"> primality</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/random"><h3 class="name">coq-random</h3></a><p class="description">Interpretation of random programs.

This contribution is a modelisation of random programs
as measures in Coq. It started in 2004 in the context
of the AVERROES project (http://www-verimag.imag.fr/AVERROES/).
It is based on comon work with Philippe Audebaud (ENS Lyon).
It was last updated in february 2007.

It contains the following elements
- an axiomatisation of the interval [0,1] and derived properties
(files Ubase.v and Uprop.v);

- a definition of measures on a type A as functions of type
(A->[0,1])->[0,1] enjoying special stability properties (files
Monads.v and Probas.v); proofs that these constructions have a
monadic structure;

- an interpretation of programs of type A as measures, in particular
a fixpoint construction; the definition of an axiomatic semantic for
deriving judgements such as ``the probability of an expression e to
evaluate to a result satisfying property q belongs to an interval [p,q]''
(file Prog.v);

- Proof of probabilistic termination of a linear random walk (file
Iterflip.v);

- Proof of a program implementing a bernoulli distribution
(Proba(bernouilli(p)=true)=p) using a coin flip and the derived binomial
law (Proba(binomial p n=k)=C(n,k)p^k(1-p)^{n-k}) (file Bernoulli.v);

- Proof of estimation of the combination of two random executions
(file Choice.v)

- Proof of partial termination of parameterized random walk (file Ycart.v)

- Definition of a measure on traces from a mesure on transitions
steps (file Nelist.v, Transitions.v)

The document random.pdf contains a short introduction to the library
associated to the Gallina source code of the library.
</p><div class="metadata"><div class="authors">author: <span class="author">Christine Paulin</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span><span class="category"> Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span></div><div class="keywords">keywords: <span class="keyword">randomized algorithms</span><span class="keyword">monads</span><span class="keyword">probability</span><span class="keyword"> randomized algorithms</span><span class="keyword"> monads</span><span class="keyword"> probability</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/coq-hello-world"><h3 class="name">coq-io-hello-world</h3></a><p class="description">A Hello World program in Coq.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">versions: <span class="version">1.1.0</span><span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/three-gap"><h3 class="name">coq-three-gap</h3></a><p class="description">A Proof of the Three Gap Theorem (Steinhaus Conjecture).

This proof uses the real numbers. It is a classical proof.
</p><div class="metadata"><div class="authors">author: <span class="author">Micaela Mayero</span></div><div class="categories">categories: <span class="category">Mathematics/Geometry/General</span><span class="category">Mathematics/Arithmetic and Number Theory/Miscellaneous</span><span class="category"> Mathematics/Geometry/See also</span><span class="category"> Mathematics/Arithmetic and Number Theory/Miscellaneous</span></div><div class="keywords">keywords: <span class="keyword">real numbers</span><span class="keyword">steinhaus</span><span class="keyword">three gap theorem</span><span class="keyword"> Real Numbers</span><span class="keyword"> Steinhaus</span><span class="keyword"> Three Gap Theorem</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://math-comp.github.io/math-comp/"><h3 class="name">coq-mathcomp-algebra</h3></a><p class="description">Mathematical Components Library on Algebra

This library contains definitions and theorems about discrete
(i.e. with decidable equality) algebraic structures : ring, fields,
ordered fields, real fields,  modules, algebras, integers, rational
numbers, polynomials, matrices, vector spaces...</p><div class="metadata"><div class="authors">authors: <span class="author">Jeremy Avigad</span><span class="author">Andrea Asperti</span><span class="author">Stephane Le Roux</span><span class="author">Yves Bertot</span><span class="author">Laurence Rideau</span><span class="author">Enrico Tassi</span><span class="author">Ioana Pasca</span><span class="author">Georges Gonthier</span><span class="author">Sidi Ould Biha</span><span class="author">Cyril Cohen</span><span class="author">Francois Garillot</span><span class="author">Alexey Solovyev</span><span class="author">Russell O'Connor</span><span class="author">Laurent Théry</span><span class="author">Assia Mahboubi</span></div><div class="keywords">keywords: <span class="keyword">algebra</span><span class="keyword">small scale reflection</span><span class="keyword">mathematical components</span><span class="keyword">odd order theorem</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.6</span><span class="version">1.6.2</span><span class="version">1.6.1</span><span class="version">1.7.0</span><span class="version">1.6.4</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/lemma-overloading"><h3 class="name">coq-lemma-overloading</h3></a><p class="description">How to Make Ad Hoc Proof Automation Less Ad Hoc.

Most interactive theorem provers provide support for some form of
user-customizable proof automation. In a number of popular systems,
such as Coq and Isabelle, this automation is achieved primarily
through *tactics*, which are programmed in a separate language
from that of the prover's base logic. While tactics are clearly
useful in practice, they can be difficult to maintain and compose
because, unlike lemmas, their behavior cannot be specified within the
expressive type system of the prover itself.

We propose a novel approach to proof automation in Coq that allows the
user to specify the behavior of custom automated routines in terms of
Coq's own type system. Our approach involves a sophisticated
application of Coq's *canonical structures*, which generalize Haskell
type classes and facilitate a flexible style of dependently-typed
logic programming. Specifically, just as Haskell type classes are
used to infer the canonical implementation of an overloaded term at a
given type, canonical structures can be used to infer the canonical
*proof* of an overloaded *lemma* for a given instantiation of its
parameters. We present a series of design patterns for canonical
structure programming that enable one to carefully and predictably
coax Coq's type inference engine into triggering the execution of
user-supplied algorithms during unification, and we illustrate these
patterns through several realistic examples drawn from Hoare Type
Theory. We assume no prior knowledge of Coq and describe the relevant
aspects of Coq type inference from first principles.
</p><div class="metadata"><div class="authors">authors: <span class="author">Derek Dreyer</span><span class="author">Georges Gonthier</span><span class="author">Beta Ziliani</span><span class="author">Aleksandar Nanevski</span></div><div class="dates">date: <span class="date">2018-07-24</span></div><div class="categories">category: <span class="category">Computer Science/Data Types and Data Structures</span></div><div class="keywords">keywords: <span class="keyword">lemma overloading</span><span class="keyword">proof automation</span><span class="keyword">hoare type theory</span><span class="keyword">canonical structures</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.8.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq/bignums"><h3 class="name">coq-bignums</h3></a><p class="description">Bignums, the Coq library of arbitrary large numbers
Provides BigN, BigZ, BigQ that used to be part of Coq standard library < 8.7.
</p><div class="metadata"><div class="authors">authors: <span class="author">Laurent Théry</span><span class="author">Benjamin Grégoire</span><span class="author">Arnaud Spiwack</span><span class="author">Evgeny Makarov</span><span class="author">Pierre Letouzey</span></div><div class="dates">date: <span class="date">2017-06-15</span></div><div class="categories">categories: <span class="category">Miscellaneous/Coq Extensions</span><span class="category">Mathematics/Arithmetic and Number Theory/Number theory</span><span class="category">Mathematics/Arithmetic and Number Theory/Rational numbers</span></div><div class="keywords">keywords: <span class="keyword">integer numbers</span><span class="keyword">rational numbers</span><span class="keyword">arithmetic</span><span class="keyword">arbitrary-precision</span></div><div class="versions">versions: <span class="version">8.7.dev</span><span class="version">8.7.0</span><span class="version">8.8.0</span><span class="version">8.8.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/search-trees"><h3 class="name">coq-search-trees</h3></a><p class="description">Binary Search Trees.

Algorithms for collecting, searching, inserting and deleting elements in binary search trees on Z
</p><div class="metadata"><div class="authors">author: <span class="author">Pierre Castéran</span></div><div class="categories">categories: <span class="category">Computer Science/Data Types and Data Structures</span><span class="category">Miscellaneous/Extracted Programs/Data structures</span><span class="category"> Computer Science/Data Types and Data Structures</span><span class="category"> Miscellaneous/Extracted Programs/Data structures</span></div><div class="keywords">keywords: <span class="keyword">binary search trees</span><span class="keyword"> binary search trees</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/int-map"><h3 class="name">coq-int-map</h3></a><p class="description">Maps indexed by binary integers : IntMap.

This library contains a data structure for finite sets implemented by
an efficient structure of map (trees indexed by binary integers).
It was initially developed by Jean Goubault.

This user contribution used to be part of Coq Standard Library.
It is now considered to be obsolete and subsumed by the new
FSets/FMap library. IntMap can be now seen as a particular
implementation of FMapInterface, see file FMapIntMap.
</p><div class="metadata"><div class="authors">author: <span class="author">Jean Goubault</span></div><div class="dates">date: <span class="date">around 1999 (integrated within Coq 7.0)</span><span class="date"> around 1999 (integrated within Coq 7.0)</span></div><div class="categories">categories: <span class="category">Computer Science/Data Types and Data Structures</span><span class="category"> Computer Science/Data Types and Data Structures</span></div><div class="keywords">keywords: <span class="keyword">finite sets</span><span class="keyword">maps</span><span class="keyword">binary integers</span><span class="keyword">efficient data structures</span><span class="keyword">data structures</span><span class="keyword"> finite sets</span><span class="keyword"> maps</span><span class="keyword"> binary integers</span><span class="keyword"> efficient data structures</span><span class="keyword"> data structures</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/nfix"><h3 class="name">coq-nfix</h3></a><p class="description">Nfix: a Coq extension for fixpoints on nested inductives.

This plugin provides a syntactic extension that allows one to write mutual fixpoints over nested inductives.
</p><div class="metadata"><div class="authors">author: <span class="author">Stéphane Lescuyer</span></div><div class="categories">categories: <span class="category">Miscellaneous/Coq Extensions</span><span class="category"> Miscellaneous/Coq Extensions</span></div><div class="keywords">keywords: <span class="keyword">mutual fixpoint functions</span><span class="keyword"> mutual fixpoint functions</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://amintimany.github.io/UniverseComparator/html/test.html"><h3 class="name">coq-universe-comparator</h3></a><p class="description">A tool to compare universe levels in Coq.
</p><div class="metadata"><div class="authors">author: <span class="author">Amin Timany</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.1.0</span><span class="version">1.0.1</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://vst.cs.princeton.edu/download/"><h3 class="name">coq-vst</h3></a><p class="description">Verified Software Toolchain

The software toolchain includes static analyzers to check assertions about your program; optimizing compilers to translate your program to machine language; operating systems and libraries to supply context for your program. The Verified Software Toolchain project assures with machine-checked proofs that the assertions claimed at the top of the toolchain really hold in the machine-language program, running in the operating-system context.
</p><div class="metadata"><div class="authors">authors: <span class="author">Andrew W. Appel</span><span class="author">Lennart Beringer</span><span class="author">Jean-Marie Madiot</span><span class="author">Qinxiang Cao</span><span class="author">Santiago Cuellar</span><span class="author">Nick Giannarakis</span><span class="author">Sandrine Blazy</span><span class="author">Robert Dockins</span><span class="author">Josiah Dodds</span><span class="author">Samuel Gruetter</span><span class="author">Aquinas Hobor</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.dev</span><span class="version">8.6.dev</span><span class="version">2.2</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://www.maximedenes.fr/content/coqeal-coq-effective-algebra-library"><h3 class="name">coq-coqeal-refinements</h3></a><p class="description">A refinement framework (for algebra).
</p><div class="metadata"><div class="versions">version: <span class="version">0.9.1</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://www.cyrilcohen.fr"><h3 class="name">coq-mathcomp-finmap</h3></a><p class="description">Finite sets, finite maps, finitely supported functions, orders.

This library is an extension of mathematical component in order to
support finite sets and finite maps on choicetypes (rather that finite
types). This includes support for functions with finite support and
multisets. The library also contains a generic order and set libary,
which will be used to subsume notations for finite sets, eventually.</p><div class="metadata"><div class="authors">author: <span class="author">Cyril Cohen</span></div><div class="keywords">keywords: <span class="keyword">finmap</span><span class="keyword">finset</span><span class="keyword">multiset</span><span class="keyword">order</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.1.0</span><span class="version">1.0.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://mattam82.github.io/Coq-Equations"><h3 class="name">coq-equations</h3></a><p class="description">A function definition package for Coq
</p><div class="metadata"><div class="authors">authors: <span class="author">Matthieu Sozeau</span><span class="author">Cyprien Mangin</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">1.0+8.7</span><span class="version">1.0~beta2</span><span class="version">1.1+8.8</span><span class="version">0.9~beta2</span><span class="version">1.0</span><span class="version">1.0~beta2+8.7</span><span class="version">1.0~beta</span><span class="version">8.8.dev</span><span class="version">8.7.dev</span><span class="version">1.0+8.8</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://plv.csail.mit.edu/bedrock/"><h3 class="name">coq-bedrock</h3></a><p class="description">[PORTING IN PROGRESS] Mostly automated verification of higher-order programs with higher-order separation logic, with a small trusted code base.  Note that somet things are still broken with 8.6, and this is primarily for benchmarking/compatibility testing purposes, at the moment.
</p><div class="metadata"><div class="authors">authors: <span class="author">Adam Chlipala</span><span class="author">Gregory Malecha</span><span class="author">Thomas Braibant</span><span class="author">Patrick Hulin</span><span class="author">Edward Z. Yang</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.7.dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/gmalecha/coq-smt-check"><h3 class="name">coq-smt-check</h3></a><p class="description">Invoke SMT solvers to check goals.
</p><div class="metadata"><div class="versions">versions: <span class="version">1.0.0</span><span class="version">2.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://math-comp.github.io/math-comp/"><h3 class="name">coq-mathcomp-ssreflect</h3></a><p class="description">Small Scale Reflection

This library includes the small scale reflection proof language
extension and the minimal set of libraries to take advantage of it.
This includes libraries on lists (seq), boolean and boolean
predicates, natural numbers and types with decidable equality,
finite types, finite sets, finite functions, finite graphs, basic arithmetics
and prime numbers, big operators
</p><div class="metadata"><div class="authors">authors: <span class="author">Jeremy Avigad</span><span class="author">Andrea Asperti</span><span class="author">Stephane Le Roux</span><span class="author">Yves Bertot</span><span class="author">Laurence Rideau</span><span class="author">Enrico Tassi</span><span class="author">Ioana Pasca</span><span class="author">Georges Gonthier</span><span class="author">Sidi Ould Biha</span><span class="author">Cyril Cohen</span><span class="author">Francois Garillot</span><span class="author">Alexey Solovyev</span><span class="author">Russell O'Connor</span><span class="author">Laurent Théry</span><span class="author">Assia Mahboubi</span></div><div class="keywords">keywords: <span class="keyword">small scale reflection</span><span class="keyword">mathematical components</span><span class="keyword">odd order theorem</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.6</span><span class="version">1.6.4</span><span class="version">1.6.2</span><span class="version">1.6.1</span><span class="version">1.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/ccs"><h3 class="name">coq-ccs</h3></a><p class="description">Equivalence notions on labelled transitions systems.

We give the specification of three different notions of equivalence
classically defined on labelled transitions systems underlying the
theories of process algebra (and particularly CCS). The fundamentals
properties of these equivalence notions are proven.
</p><div class="metadata"><div class="authors">author: <span class="author">Solange Coupet-Grimal</span></div><div class="categories">categories: <span class="category">Computer Science/Concurrent Systems and Protocols/Theory of concurrent systems</span><span class="category"> Computer Science/Concurrent Systems and Protocols/Theory of concurrent systems</span></div><div class="keywords">keywords: <span class="keyword">labelled transitions systems</span><span class="keyword">process algebra</span><span class="keyword">calculus of concurrent process (ccs)</span><span class="keyword"> Labelled Transitions Systems</span><span class="keyword"> Process Algebra</span><span class="keyword"> Calculus of Concurrent Process (CCS)</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/cours-de-coq"><h3 class="name">coq-cours-de-coq</h3></a><p class="description">Various examples of Coq proofs.

Various simple examples of Coq proofs
</p><div class="metadata"><div class="authors">authors: <span class="author">Frédéric Prost</span><span class="author">Gilles Kahn</span></div><div class="categories">categories: <span class="category">Miscellaneous/Coq Use Examples</span><span class="category"> Miscellaneous/Coq Use Examples</span></div><div class="keywords">keywords: <span class="keyword">coq</span><span class="keyword">examples</span><span class="keyword"> Coq</span><span class="keyword"> examples</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/topology"><h3 class="name">coq-topology</h3></a><p class="description">General Topology.

This library develops some of the basic concepts and results of general topology.
</p><div class="metadata"><div class="authors">author: <span class="author">Daniel Schepler</span></div><div class="categories">categories: <span class="category">Mathematics/Real Calculus and Topology</span><span class="category"> Mathematics/Real Calculus and Topology</span></div><div class="keywords">keywords: <span class="keyword">topology</span><span class="keyword">filters</span><span class="keyword">nets</span><span class="keyword">metric spaces</span><span class="keyword">real analysis</span><span class="keyword">urysohn's lemma</span><span class="keyword">tietze extension theorem</span><span class="keyword"> topology</span><span class="keyword"> filters</span><span class="keyword"> nets</span><span class="keyword"> metric spaces</span><span class="keyword"> real analysis</span><span class="keyword"> Urysohn's lemma</span><span class="keyword"> Tietze extension theorem</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/ctltctl"><h3 class="name">coq-ctltctl</h3></a><p class="description">Computation Tree Logic for Reactive Systems and Timed Computation Tree Logic for Real Time Systems.

This library formalises two logics for reasoning about
reactive systems (CTL) and real time systems (TCTL) represents using
timed automatas (timed graphs) with discrete time.
</p><div class="metadata"><div class="authors">author: <span class="author">Carlos Daniel Luna</span></div><div class="dates">date: <span class="date">February-March 2000</span></div><div class="categories">category: <span class="category">Mathematics/Logic/Modal logic</span></div><div class="keywords">keywords: <span class="keyword">ctl</span><span class="keyword">tctl</span><span class="keyword">real time systems</span><span class="keyword">reactive systems</span><span class="keyword">temporal logic</span><span class="keyword">timed automatas</span><span class="keyword">timed graphs</span><span class="keyword">discrete time</span><span class="keyword">modal logic</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/amm11262"><h3 class="name">coq-amm11262</h3></a><p class="description">Problem 11262 of The American Mathematical Monthly.

Formalisation of Tonny Hurkens' proof of the problem
11262 of The American Mathematical Monthly 113(10), Dec. 2006
(see the README files)
</p><div class="metadata"><div class="authors">authors: <span class="author">Tonny Hurkens (paper proof)</span><span class="author">Milad Niqui (Coq files)</span></div><div class="dates">date: <span class="date">2007-04</span><span class="date"> 2007-04</span></div><div class="keywords">keywords: <span class="keyword">american mathematical monthly problem 11262</span><span class="keyword"> american mathematical monthly problem 11262</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/UniMath/UniMath"><h3 class="name">coq-unimath-foundations</h3></a><p class="description">Aims to formalize a substantial body of mathematics using the univalent point of view. 
</p><div class="metadata"><div class="authors">author: <span class="author">The UniMath Development Team</span></div><div class="versions">version: <span class="version">0.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://gitlab.inria.fr/charguer/tlc"><h3 class="name">coq-tlc</h3></a><p class="description">A general-purpose alternative to Coq's standard library.

TLC relies on the axioms of functional extensionality, propositional
extensionality, and indefinite description (also known as Hilbert's epsilon
operator). The consequences of these axioms include the law of the excluded
middle as well as proof irrelevance. Accepting these axioms often makes life
significantly simpler.

TLC takes advantage of Coq's type class mechanism. In particular, this allows
for common operators and lemma names for all container data structures and all
order relations.

TLC includes the optimal fixed point combinator, which allows
arbitrarily-complex recursive and co-recursive definitions.

TLC provides a collection of tactics that enhance the default tactics provided
by Coq. These tactics help construct more concise and more robust proof
scripts.
</p><div class="metadata"><div class="authors">author: <span class="author">Arthur Charguéraud</span></div><div class="versions">versions: <span class="version">20181116</span><span class="version">20161010</span><span class="version">20180316</span><span class="version">20171128</span><span class="version">20171206</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/demos"><h3 class="name">coq-demos</h3></a><p class="description">Demos of some Coq tools appeared in version V6.0.

Example of sorting algorithms defined using the Cases
(pattern-matching) construction. Demo of the decision tactic Tauto for
intuitionistic propositional calculus. Demo of the AutoRewrite tactic. Demo of
the Prolog tactic applied to the compilation of miniML programs.
</p><div class="metadata"><div class="authors">author: <span class="author">Coq group</span></div><div class="categories">category: <span class="category">Miscellaneous/Coq Use Examples</span></div><div class="keywords">keywords: <span class="keyword">sorting</span><span class="keyword">cases</span><span class="keyword">tauto</span><span class="keyword">autorewrite</span><span class="keyword">prolog</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/icharate"><h3 class="name">coq-icharate</h3></a><p class="description">Icharate: A logical Toolkit for Multimodal Categorial Grammars.

The logical toolkit ICHARATE is built upon a formalization of
multimodal categorial grammars in Coq proof assistant.
This toolkit aims at facilitating the study of these
complicated formalisms by allowing users to build interactively the
syntactic derivations of different sentences, compute their
semantic interpretations and also prove universal properties of entire
classes of grammars using a collection of already established derived
rules. Several tactics are defined to ease the interaction with users.
</p><div class="metadata"><div class="authors">authors: <span class="author">Houda Anoun</span><span class="author">Pierre Castéran</span></div><div class="dates">date: <span class="date">2003-2006</span></div><div class="categories">category: <span class="category">Computer Science/Formal Languages Theory and Automata</span></div><div class="keywords">keywords: <span class="keyword">multimodal categorial grammars</span><span class="keyword">syntax/semantics interface</span><span class="keyword">higher order logic</span><span class="keyword">meta linguistics</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/automata"><h3 class="name">coq-automata</h3></a><p class="description">Beginning of formal language theory.

This library formalises the beginning of formal language theory:
finite automata and rational languages, context-free grammars
and push-down automata.
</p><div class="metadata"><div class="authors">authors: <span class="author">Jean-Christophe Filliâtre</span><span class="author">Judicaël Courant</span></div><div class="dates">date: <span class="date">June-July 1993</span></div><div class="categories">category: <span class="category">Computer Science/Formal Languages Theory and Automata</span></div><div class="keywords">keywords: <span class="keyword">formal language theory</span><span class="keyword">finite automata</span><span class="keyword">push down automatas</span><span class="keyword">rational langages</span><span class="keyword">kleene</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://softwarefoundations.cis.upenn.edu/"><h3 class="name">coq-sf-plf</h3></a><p class="description">Programming Language Foundations (Volume 2 of Software Foundations)

Programming Language Foundations, surveys the theory of programming languages, including operational semantics, Hoare logic, and static type systems.
</p><div class="metadata"><div class="authors">authors: <span class="author">Benjamin C. Pierce</span><span class="author">Arthur Azevedo de Amorim</span><span class="author">Chris Casinghino</span><span class="author">Marco Gaboardi</span><span class="author">Michael Greenberg</span><span class="author">Cătălin Hriţcu</span><span class="author">Vilhelm Sjöberg</span><span class="author">Andrew Tolmach</span><span class="author">Brent Yorgey</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/fssec-model"><h3 class="name">coq-fssec-model</h3></a><p class="description">Formal verification of an extension of a UNIX compatible, secure filesystem.
</p><div class="metadata"><div class="authors">author: <span class="author">Maximiliano Cristiá</span></div><div class="dates">date: <span class="date">2002-04-24</span><span class="date"> 2002-04-24</span></div><div class="categories">categories: <span class="category">Computer Science/Operating Systems</span><span class="category"> Computer Science/Operating Systems</span></div><div class="keywords">keywords: <span class="keyword">security</span><span class="keyword">filesystem</span><span class="keyword">unix</span><span class="keyword">mls</span><span class="keyword">access control</span><span class="keyword"> security</span><span class="keyword"> filesystem</span><span class="keyword"> UNIX</span><span class="keyword"> MLS</span><span class="keyword"> access control</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/concat"><h3 class="name">coq-concat</h3></a><p class="description">Constructive Category Theory.
</p><div class="metadata"><div class="authors">author: <span class="author">Amokrane Saïbi</span></div><div class="categories">categories: <span class="category">Mathematics/Category Theory</span><span class="category"> Mathematics/Category Theory</span></div><div class="keywords">keywords: <span class="keyword">category theory</span><span class="keyword"> category theory</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/DistributedComponents/InfSeqExt"><h3 class="name">coq-inf-seq-ext</h3></a><p class="description">InfSeqExt is a collection of Coq libraries for reasoning inductively and coinductively on infinite sequences, using modal operators similar to those in linear temporal logic (LTL).
</p><div class="metadata"><div class="authors">authors: <span class="author">Yuxin Deng</span><span class="author">Jean-Francois Monin</span><span class="author">Karl Palmskog</span></div><div class="categories">category: <span class="category">Mathematics/Logic/Modal logic</span></div><div class="keywords">keywords: <span class="keyword">temporal logic</span><span class="keyword">infinite transition systems</span><span class="keyword">coinduction</span></div><div class="versions">versions: <span class="version">8.7.dev</span><span class="version">8.6.dev</span><span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/dblib"><h3 class="name">coq-dblib</h3></a><p class="description">dblib.

The dblib library offers facilities for working with de Bruijn indices.
</p><div class="metadata"><div class="authors">author: <span class="author">Francois Pottier</span></div><div class="categories">categories: <span class="category">Computer Science/Lambda Calculi</span><span class="category"> Computer Science/Lambda Calculi</span></div><div class="keywords">keywords: <span class="keyword">abstract syntax</span><span class="keyword">binders</span><span class="keyword">de bruijn indices</span><span class="keyword">shift</span><span class="keyword">lift</span><span class="keyword">substitution</span><span class="keyword"> abstract syntax</span><span class="keyword"> binders</span><span class="keyword"> de Bruijn indices</span><span class="keyword"> shift</span><span class="keyword"> lift</span><span class="keyword"> substitution</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/semantics"><h3 class="name">coq-semantics</h3></a><p class="description">A survey of semantics styles, from natural semantics through structural operational, axiomatic, and denotational semantics, to.
abstract interpretation.

This is a survey of programming language semantics styles
for a miniature example of a programming language, with their encoding
in Coq, the proofs of equivalence of different styles, and the proof
of soundess of tools obtained from axiomatic semantics or abstract
interpretation. The tools can be run inside Coq, thus making them
available for proof by reflection, and the code can also be extracted
and connected to a yacc-based parser, thanks to the use of a functor
parameterized by a module type of strings. A hand-written parser is
also provided in Coq, but there are no proofs associated.
</p><div class="metadata"><div class="authors">author: <span class="author">Yves Bertot</span></div><div class="dates">date: <span class="date">2007-07-5</span><span class="date"> 2007-07-5</span></div><div class="categories">categories: <span class="category">Computer Science/Semantics and Compilation/Semantics</span><span class="category"> Computer Science/Semantics and Compilation/Semantics</span></div><div class="keywords">keywords: <span class="keyword">natural semantics</span><span class="keyword">denotational semantics</span><span class="keyword">axiomatic</span><span class="keyword">semantics</span><span class="keyword">hoare logic</span><span class="keyword">dijkstra weakest pre condition calculus</span><span class="keyword">abstract interpretation</span><span class="keyword">intervals</span><span class="keyword"> natural semantics</span><span class="keyword"> denotational semantics</span><span class="keyword"> axiomatic semantics</span><span class="keyword"> Hoare logic</span><span class="keyword"> Dijkstra weakest pre-condition calculus</span><span class="keyword"> abstract interpretation</span><span class="keyword"> intervals</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/coalgebras"><h3 class="name">coq-coalgebras</h3></a><p class="description">Coalgebras, bisimulation and lambda-coiteration.

This contribution contains a formalisation of coalgebras, bisimulation on coalgebras, weakly final coalgebras, lambda-coiteration definition scheme (including primitive corecursion) and a version of lambda-bisimulation. The formalisation is modular. The implementation of the module types for streams and potentially infinite Peano numbers are provided using the coinductive types.
</p><div class="metadata"><div class="authors">author: <span class="author">Milad Niqui</span></div><div class="dates">date: <span class="date">2008-10</span></div><div class="categories">category: <span class="category">Mathematics/Category Theory</span></div><div class="keywords">keywords: <span class="keyword">coalgebra</span><span class="keyword">bisimulation</span><span class="keyword">weakly final</span><span class="keyword">coiteration</span><span class="keyword">coinductive types</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-concurrency/system"><h3 class="name">coq-concurrency-system</h3></a><p class="description">Experimental library to write concurrent applications in Coq.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">versions: <span class="version">1.0.0</span><span class="version">1.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/legacy-ring"><h3 class="name">coq-legacy-ring</h3></a><p class="description">The former implementation of the ring tactic.
</p><div class="metadata"><div class="authors">authors: <span class="author">Bruno Barras</span><span class="author">Benjamin Gregoire</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/io"><h3 class="name">coq-io</h3></a><p class="description">A library for effects in Coq.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">versions: <span class="version">3.3.0</span><span class="version">2.0.0</span><span class="version">2.1.0</span><span class="version">3.2.0</span><span class="version">3.0.0</span><span class="version">3.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/checker"><h3 class="name">coq-checker</h3></a><p class="description">The Mutilated Checkerboard.
</p><div class="metadata"><div class="authors">author: <span class="author">Gérard Huet</span></div><div class="categories">categories: <span class="category">Miscellaneous/Logical Puzzles and Entertainment</span><span class="category"> Miscellaneous/Logical Puzzles and Entertainment</span></div><div class="keywords">keywords: <span class="keyword">checker</span><span class="keyword">dominos</span><span class="keyword">puzzles</span><span class="keyword"> checker</span><span class="keyword"> dominos</span><span class="keyword"> puzzles</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/counting"><h3 class="name">coq-counting</h3></a><p class="description">Counting: a Coq plugin for measuring definitions/proofs.

This plugin keeps the count of the size of definitions and proofs in the current Coq session.
</p><div class="metadata"><div class="authors">author: <span class="author">Stéphane Lescuyer</span></div><div class="categories">category: <span class="category">Miscellaneous/Coq Extensions</span></div><div class="keywords">keyword: <span class="keyword">statistics</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/gmalecha/template-coq"><h3 class="name">coq-template-coq</h3></a><p class="description">A quoting library for Coq.
</p><div class="metadata"><div class="authors">authors: <span class="author">Gregory Malecha</span><span class="author">Abhishek Anand</span><span class="author">Simon Boulier</span><span class="author">Cyril Cohen</span><span class="author">Matthieu Sozeau</span><span class="author">Nicolas Tabareau</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">2.1~beta3</span><span class="version">1.0.0~beta2</span><span class="version">2.1~beta</span><span class="version">1.1.0~beta2</span><span class="version">8.5.dev</span><span class="version">1.1.0~beta3</span><span class="version">8.7.dev</span><span class="version">2.0~beta</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://gappa.gforge.inria.fr/"><h3 class="name">coq-gappa</h3></a><p class="description">A Coq tactic for discharging goals about floating-point arithmetic and
round-off errors using the Gappa prover.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Melquiond</span></div><div class="categories">category: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span></div><div class="keywords">keywords: <span class="keyword">floating point arithmetic</span><span class="keyword">interval arithmetic</span><span class="keyword">decision procedure</span></div><div class="versions">versions: <span class="version">1.3.3</span><span class="version">1.3.2</span><span class="version">1.2.1</span><span class="version">1.4.0</span><span class="version">1.3.4</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/exact-real-arithmetic"><h3 class="name">coq-exact-real-arithmetic</h3></a><p class="description">Exact Real Arithmetic.

This contribution contains a proof of correctness
of some exact real arithmetic algorithms from the PhD thesis of
Valérie Ménissier-Morain
</p><div class="metadata"><div class="authors">author: <span class="author">Jérôme Creci</span></div><div class="categories">category: <span class="category">Mathematics/Arithmetic and Number Theory/Real numbers</span></div><div class="keywords">keywords: <span class="keyword">correctness</span><span class="keyword">real numbers</span><span class="keyword">arithmetic</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/ergo"><h3 class="name">coq-ergo</h3></a><p class="description">Ergo: a Coq plugin for reification of term with arbitrary signature.

This library provides a tactic that performs SMT solving (SAT + congruence closure + arithmetic).
</p><div class="metadata"><div class="authors">author: <span class="author">Stéphane Lescuyer</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span><span class="category"> Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span></div><div class="keywords">keywords: <span class="keyword">reflexive tactic</span><span class="keyword">decision procedure</span><span class="keyword">satisfiability modulo theories</span><span class="keyword"> reflexive decision procedure</span><span class="keyword"> satisfiability modulo theories</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/subst"><h3 class="name">coq-subst</h3></a><p class="description">The confluence of Hardin-Lévy lambda-sigma-lift-calcul.

The confluence of Hardin-Lévy lambda-sigma-lift-calcul is
proven. By the way, several standard definition and results about
rewriting systems are proven (Newman's lemma, Yokouchi's lemma, ...).
</p><div class="metadata"><div class="authors">author: <span class="author">Amokrane Saïbi</span></div><div class="categories">categories: <span class="category">Computer Science/Lambda Calculi</span><span class="category"> Computer Science/Lambda Calculi</span></div><div class="keywords">keywords: <span class="keyword">lambda sigma lift calculus</span><span class="keyword">explicit substitution</span><span class="keyword">newman's lemma</span><span class="keyword">yokouchi's lemma</span><span class="keyword">confluence</span><span class="keyword">rewriting</span><span class="keyword"> lambda-sigma-lift-calculus</span><span class="keyword"> explicit substitution</span><span class="keyword"> Newman's lemma</span><span class="keyword"> Yokouchi's lemma</span><span class="keyword"> confluence</span><span class="keyword"> rewriting</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/fsets"><h3 class="name">coq-fsets</h3></a><p class="description">Finite Sets overs Ordered Types.

This contribution contains several implementations of finite sets over
arbitrary ordered types using functors. Currently, there are 3
implementations: sorted lists, red-black trees and AVLs.
</p><div class="metadata"><div class="authors">authors: <span class="author">Jean-Christophe Filliâtre</span><span class="author">Pierre Letouzey</span></div><div class="categories">categories: <span class="category">Computer Science/Data Types and Data Structures</span><span class="category">Miscellaneous/Extracted Programs/Data structures</span><span class="category"> Computer Science/Data Types and Data Structures</span><span class="category"> Miscellaneous/Extracted Programs/Data structures</span></div><div class="keywords">keywords: <span class="keyword">finite sets</span><span class="keyword">sorted lists</span><span class="keyword">balanced trees</span><span class="keyword">red black trees</span><span class="keyword">avl</span><span class="keyword">functors</span><span class="keyword">data structures</span><span class="keyword"> Finite Sets</span><span class="keyword"> Sorted lists</span><span class="keyword"> Balanced trees</span><span class="keyword"> Red-black trees</span><span class="keyword"> AVL</span><span class="keyword"> Functors</span><span class="keyword"> data structures</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/snu-sf/paco/"><h3 class="name">coq-paco</h3></a><p class="description">Paco: Parameterized Coinduction.

Paco is a Coq library implementing parameterized coinduction. Parameterized coinduction is a technique for defining coinductive predicates (i.e., in Prop), using which one can perform coinductive proofs in a more compositional and incremental fashion than with standard Tarski-style constructions.

The Paco library provides a tactic called "pcofix", replacing Coq's primitive cofix and avoiding its syntactic guardedness checking of proof terms. We have found that pcofix yields clear performance and usability benefits, even on simple examples.</p><div class="metadata"><div class="authors">authors: <span class="author">Chung-Kil Hur</span><span class="author">Georg Neis</span><span class="author">Derek Dreyer</span><span class="author">Viktor Vafeiadis</span></div><div class="dates">date: <span class="date">2018-02-11</span></div><div class="categories">categories: <span class="category">Programming Languages/Formal Definitions and Theory</span><span class="category">Mathematical Logic and Foramal Languages/Mathematical Logic</span></div><div class="keywords">keywords: <span class="keyword">coinduction</span><span class="keyword">simulation</span><span class="keyword">parameterized greatest fixed point</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.2.8</span><span class="version">1.2.9</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/davidnowak/cecoa"><h3 class="name">coq-cecoa</h3></a><p class="description">Implicit-complexity Coq library to prove that some programs are computable in polynomial time
</p><div class="metadata"><div class="authors">authors: <span class="author">Hugo Férée</span><span class="author">Samuel Hym</span><span class="author">Micaela Mayero</span><span class="author">Jean-Yves Moyen</span><span class="author">David Nowak</span></div><div class="dates">date: <span class="date">2018-09-10</span></div><div class="categories">category: <span class="category">CS/Algo/Complexity</span></div><div class="keywords">keywords: <span class="keyword">implicit complexity</span><span class="keyword">polynomial time</span><span class="keyword">rewriting</span></div><div class="versions">version: <span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/hardware"><h3 class="name">coq-hardware</h3></a><p class="description">Verification and synthesis of hardware linear arithmetic structures.

Verification and synthesis of hardware linear arithmetic
structures. Example of a left-to-right comparator.
Three approaches are tackled :
- the usual verification of a circuit, consisting in proving that the
description satisfies the specification,
- the synthesis of a circuit from its specification using the Coq extractor,
- the same approach as above but using the Program tactic.
</p><div class="metadata"><div class="authors">authors: <span class="author">Solange Coupet-Grimal</span><span class="author">Line Jakubiec</span><span class="author">Solange Coupet-Grimal & Line Jakubiec</span></div><div class="categories">categories: <span class="category">Computer Science/Architecture</span><span class="category">Miscellaneous/Extracted Programs/Hardware</span><span class="category"> Computer Science/Architecture</span><span class="category"> Miscellaneous/Extracted Programs/Hardware</span></div><div class="keywords">keywords: <span class="keyword">hardware verification</span><span class="keyword">comparator circuit</span><span class="keyword"> hardware verification</span><span class="keyword"> comparator circuit</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://geocoq.github.io/GeoCoq/"><h3 class="name">coq-geocoq</h3></a><p class="description">A formalization of foundations of geometry in Coq
</p><div class="metadata"><div class="authors">authors: <span class="author">Michael Beeson</span><span class="author">Gabriel Braun</span><span class="author">Pierre Boutry</span><span class="author">Charly Gries</span><span class="author">Julien Narboux</span></div><div class="categories">category: <span class="category">Mathematics/Geometry/General</span></div><div class="keywords">keywords: <span class="keyword">geometry</span><span class="keyword">neutral geometry</span><span class="keyword">euclidean geometry</span><span class="keyword">foundations</span><span class="keyword">Tarski</span><span class="keyword">hilbert</span><span class="keyword">Pappus</span><span class="keyword">desargues</span><span class="keyword">parallel postulates</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.0.1</span><span class="version">2.1.0</span><span class="version">2.0.0</span><span class="version">2.3.0</span><span class="version">1.1.0</span><span class="version">2.2.1</span><span class="version">8.7.dev</span><span class="version">2.2.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/querycert/jsast"><h3 class="name">coq-jsast</h3></a><p class="description">A minimal JavaScript syntax tree carved out of the JsCert project.
</p><div class="metadata"><div class="authors">author: <span class="author">Jerome Simeon</span></div><div class="versions">versions: <span class="version">1.0.8</span><span class="version">1.0.7</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/bdds"><h3 class="name">coq-bdds</h3></a><p class="description">BDD algorithms and proofs in Coq, by reflection.

Provides BDD algorithms running under Coq.
(BDD are Binary Decision Diagrams.)
Allows one to do classical validity checking by
reflection in Coq using BDDs, can also be used
to get certified BDD algorithms by extraction.
First step towards actual symbolic model-checkers
in Coq. See file README for operation.
</p><div class="metadata"><div class="authors">author: <span class="author">Kumar Neeraj Verma</span></div><div class="dates">date: <span class="date">May-July 1999</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span><span class="category">Miscellaneous/Extracted Programs/Decision procedures</span></div><div class="keywords">keywords: <span class="keyword">binary decision diagrams</span><span class="keyword">classical logic</span><span class="keyword">propositional logic</span><span class="keyword">validity</span><span class="keyword">satisfiability</span><span class="keyword">model checking</span><span class="keyword">reflection</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/artart78/coq-bitset"><h3 class="name">coq-bitset</h3></a><p class="description">A library used to prove algorithms working on OCaml native integers using representations with SSReflect's finite sets.
</p><div class="metadata"><div class="authors">authors: <span class="author">Arthur Blot</span><span class="author">Pierre-Évariste Dagand</span></div><div class="versions">version: <span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/projective-geometry"><h3 class="name">coq-projective-geometry</h3></a><p class="description">Projective Geometry.

This contributions contains elements of formalization of projective geometry.
In the plane:
Two axiom systems are shown equivalent. We prove some results about the
decidability of the the incidence and equality predicates. The classic
notion of duality between points and lines is formalized thanks to a
functor. The notion of 'flat' is defined and flats are characterized.
Fano's plane, the smallest projective plane is defined. We show that Fano's plane is desarguesian.
In the space:
We prove Desargues' theorem.
</p><div class="metadata"><div class="authors">authors: <span class="author">Nicolas Magaud</span><span class="author">Julien Narboux</span><span class="author">Pascal Schreck</span></div><div class="dates">date: <span class="date">2009-10</span></div><div class="categories">category: <span class="category">Mathematics/Geometry/General</span></div><div class="keywords">keywords: <span class="keyword">geometry</span><span class="keyword">projective</span><span class="keyword">fano</span><span class="keyword">homogeneous coordinates model</span><span class="keyword">flat</span><span class="keyword">rank</span><span class="keyword">desargues</span><span class="keyword">moulton</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/exceptions"><h3 class="name">coq-exceptions</h3></a><p class="description">Pro[gramm,v]ing with continuations:A development in Coq.
</p><div class="metadata"><div class="authors">author: <span class="author">Pierre Castéran</span></div><div class="categories">categories: <span class="category">Computer Science/Semantics and Compilation/Semantics</span><span class="category"> Computer Science/Semantics and Compilation/Semantics</span></div><div class="keywords">keywords: <span class="keyword">exceptions</span><span class="keyword">continuations</span><span class="keyword"> exceptions</span><span class="keyword"> continuations</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/lin-alg"><h3 class="name">coq-lin-alg</h3></a><p class="description">Linear Algebra.

A development of some preliminary linear algebra
based on Chapter 1 of "Linear Algebra" by Friedberg, Insel and Spence
</p><div class="metadata"><div class="authors">author: <span class="author">Jasper Stein</span></div><div class="dates">date: <span class="date">2003-09-19</span></div><div class="categories">category: <span class="category">Mathematics/Algebra</span></div><div class="keywords">keyword: <span class="keyword">linear algebra</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://compcert.inria.fr/"><h3 class="name">coq-compcert</h3></a><p class="description">The CompCert C compiler.
</p><div class="metadata"><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">2.7.1</span><span class="version">2.3.2</span><span class="version">3.0.1</span><span class="version">2.6.0</span><span class="version">3.2.0</span><span class="version">2.5.0</span><span class="version">2.0.0</span><span class="version">3.1.0</span><span class="version">dev</span><span class="version">3.0.0</span><span class="version">8.8.dev</span><span class="version">3.3.0</span><span class="version">8.7.dev</span><span class="version">2.4.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/pautomata"><h3 class="name">coq-pautomata</h3></a><p class="description">Parameterized automata.

This contribution is a modelisation in Coq of the p-automata
designed in the CALIFE project (http://www.loria.fr/calife).
It contains an axiomatisation of time,
the definition of a p-automaton, the definition of binary and
arbitrary synchronisation of a family of p-automaton, the semantics of
a p-automaton as a labelled transition system. The description of the ABR
algorithm as a p-automaton is also given.

This work is reported in : P. Castéran, E. Freund, C. Paulin and
D. Rouillard ``Bibliothèques Coq et Isabelle-HOL pour les systèmes de
transitions et les p-automates''
</p><div class="metadata"><div class="authors">authors: <span class="author">Emmanuel Freund</span><span class="author">Christine Paulin</span><span class="author">Emmanuel Freund & Christine Paulin</span></div><div class="categories">categories: <span class="category">Computer Science/Concurrent Systems and Protocols/Theory of concurrent systems</span><span class="category"> Computer Science/Concurrent Systems and Protocols/Theory of concurrent systems</span></div><div class="keywords">keywords: <span class="keyword">p automata</span><span class="keyword">abr</span><span class="keyword">pgm</span><span class="keyword">time</span><span class="keyword"> p-automata</span><span class="keyword"> ABR</span><span class="keyword"> PGM</span><span class="keyword"> time</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/coq-cunit"><h3 class="name">coq-cunit</h3></a><p class="description">Convenience functions for unit testing in Coq.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">version: <span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/generic-environments"><h3 class="name">coq-generic-environments</h3></a><p class="description">Generic_Environments.

Generic_Environments is a library which provides an abstract data type of environments, as a functor parameterized by a module defining variables, and a function which builds environments for such variables with any Type of type. Usual operations over environments are defined, along with an extensive set of basic and more advanced properties. Moreover, an implementation using lists satisfying and all the required properties is provided.
</p><div class="metadata"><div class="authors">author: <span class="author">Emmanuel Polonowski</span></div><div class="categories">categories: <span class="category">Mathematics/Logic/Type theory</span><span class="category"> Mathematics/Logic/Type theory</span></div><div class="keywords">keywords: <span class="keyword">generic environments</span><span class="keyword">typing</span><span class="keyword">type theory</span><span class="keyword"> generic environments</span><span class="keyword"> typing</span><span class="keyword"> type theory</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/sudoku"><h3 class="name">coq-sudoku</h3></a><p class="description">A certified Sudoku solver.

A formalisation of Sudoku in Coq. It implements a naive
Davis-Putnam procedure to solve sudokus.
</p><div class="metadata"><div class="authors">author: <span class="author">Laurent Théry</span></div><div class="dates">date: <span class="date">2006-02</span><span class="date"> 2006-02</span></div><div class="categories">categories: <span class="category">Miscellaneous/Logical Puzzles and Entertainment</span><span class="category"> Miscellaneous/Logical Puzzles and Entertainment</span></div><div class="keywords">keywords: <span class="keyword">sudoku</span><span class="keyword">puzzles</span><span class="keyword">davis putnam</span><span class="keyword"> sudoku</span><span class="keyword"> puzzles</span><span class="keyword"> Davis-Putnam</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/maple-mode"><h3 class="name">coq-maple-mode</h3></a><p class="description">A Maple Mode for Coq.

This contribution is an interface between Coq and Maple. In
particular, this exports the functions simplify/factor/expand/normal giving
the corresponding tactics Simplify/Factor/Expand/Normal. The manipulations
carried out by these tactics are proved thanks to the tactic Field. These
tactics can be also used as functions by means of the Eval ... In command.
</p><div class="metadata"><div class="authors">authors: <span class="author">David Delahaye</span><span class="author">Micaela Mayero</span></div><div class="dates">date: <span class="date">2002-03</span><span class="date"> 2002-03</span></div><div class="categories">categories: <span class="category">Miscellaneous/Coq Extensions</span><span class="category"> Miscellaneous/Coq Extensions</span></div><div class="keywords">keywords: <span class="keyword">maple</span><span class="keyword">simplification</span><span class="keyword">field tactic</span><span class="keyword"> Maple</span><span class="keyword"> simplification</span><span class="keyword"> field tactic</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/domain-theory"><h3 class="name">coq-domain-theory</h3></a><p class="description">Elements of Domain Theory.

Domain theory as devised by Scott and Plotkin and
following Kahn and Plotkin paper on Concrete Domains
</p><div class="metadata"><div class="authors">author: <span class="author">Gilles Kahn</span></div><div class="categories">category: <span class="category">Computer Science/Lambda Calculi</span></div><div class="keywords">keyword: <span class="keyword">concrete domains</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/io-evaluate"><h3 class="name">coq-io-evaluate</h3></a><p class="description">Generic functions to run effects.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">version: <span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://plv.csail.mit.edu/fiat/"><h3 class="name">coq-fiat-parsers</h3></a><p class="description">Mostly automated synthesis of correct-by-construction programs.
</p><div class="metadata"><div class="authors">authors: <span class="author">Adam Chlipala</span><span class="author">Benjamin Delaware</span><span class="author">Clément Pit-Claudel</span><span class="author">Jason Gross</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.dev</span><span class="version">8.6.dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/jprover"><h3 class="name">coq-jprover</h3></a><p class="description">A theorem prover for first-order intuitionistic logic.

JProver is a theorem prover for first-order intuitionistic logic.
It is originally implemented by Stephan Schmitt and then integrated into
MetaPRL by Aleksey Nogin. After this, Huang Guan-Shieng extracted the
necessary ML-codes from MetaPRL and then adapted it to Coq.
</p><div class="metadata"><div class="authors">author: <span class="author">Huang Guan-Shieng</span></div><div class="dates">date: <span class="date">April 2002 (contribution since January 2009)</span><span class="date"> 2002-04 (contribution since January 2009)</span></div><div class="categories">categories: <span class="category">Miscellaneous/Coq Extensions</span><span class="category">Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span><span class="category"> Miscellaneous/Coq Extensions and Computer Science/Decision Procedures</span></div><div class="keywords">keywords: <span class="keyword">decision procedure</span><span class="keyword">first order logic</span><span class="keyword">intuitionistic logic</span><span class="keyword">theorem proving</span><span class="keyword">proof search</span><span class="keyword"> Decision procedures</span><span class="keyword"> First-order logic</span><span class="keyword"> Intuitionistic logic</span><span class="keyword"> Theorem proving</span><span class="keyword"> Proof search</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/additions"><h3 class="name">coq-additions</h3></a><p class="description">Addition Chains.
</p><div class="metadata"><div class="authors">author: <span class="author">Pierre Castéran</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span><span class="category">Miscellaneous/Extracted Programs/Arithmetic</span></div><div class="keywords">keyword: <span class="keyword">addition chains</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/recursive-definition"><h3 class="name">coq-recursive-definition</h3></a><p class="description">ML-like recursive definitions.

This module provides a facility to define recursive functions in
an ML-like style, giving a fixpoint equation, a variant and a
well-founded relation. A pure function is then generated, together with
a theorem giving the fixpoint equation.
THIS IS MAINLY A TEST CONTRIB, BEFORE INTEGRATION IN COQ.
</p><div class="metadata"><div class="authors">authors: <span class="author">Antonia Balaa</span><span class="author">Yves Bertot</span></div><div class="dates">date: <span class="date">2002</span><span class="date"> 2002</span></div><div class="categories">categories: <span class="category">Miscellaneous/Coq Extensions</span><span class="category"> Miscellaneous/Coq Extensions</span></div><div class="keywords">keywords: <span class="keyword">recursive functions</span><span class="keyword">well founded recursion</span><span class="keyword">well foundedness</span><span class="keyword"> recursive functions</span><span class="keyword"> well founded recursion</span><span class="keyword"> well foundedness</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://github.com/LPCIC/coq-elpi"><h3 class="name">coq-elpi</h3></a><p class="description">Elpi extension language for Coq

Coq-elpi provides a Coq plugin that embeds ELPI.
It also provides a way to embed Coq's terms into λProlog using
the Higher-Order Abstract Syntax approach
and a way to read terms back.  In addition to that it exports to ELPI a
set of Coq's primitives, e.g. printing a message, accessing the
environment of theorems and data types, defining a new constant and so on.
For convenience it also provides a quotation and anti-quotation for Coq's
syntax in λProlog.  E.g. `nat` is expanded to the type name of natural
numbers, or `A -> B` to the representation of a product by unfolding
 the `->` notation. Finally it provides a way to define new vernacular commands
and
new tactics.

</p><div class="metadata"><div class="authors">author: <span class="author">Enrico Tassi</span></div><div class="versions">versions: <span class="version">v0.1.1.dev</span><span class="version">v0.1.0.dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/qarith"><h3 class="name">coq-qarith</h3></a><p class="description">A Library for Rational Numbers (QArith).

This contribution is a proposition of a library formalizing
rational number in Coq.
</p><div class="metadata"><div class="authors">author: <span class="author">Pierre Letouzey</span></div><div class="categories">categories: <span class="category">Mathematics/Arithmetic and Number Theory/Rational numbers</span><span class="category">Miscellaneous/Extracted Programs/Arithmetic</span></div><div class="keywords">keywords: <span class="keyword">arithmetic</span><span class="keyword">rational numbers</span><span class="keyword">setoid</span><span class="keyword">ring</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/math-comp/analysis"><h3 class="name">coq-mathcomp-analysis</h3></a><p class="description">Mathematical Components Library on Analysis (DRAFT)

This library contains a DRAFT and UNSTABLE embryo of an analyis
library inspired from the Coquelicot Library, but compatible with the
Mathematical Components library. It contains libraries about real
numbers, probability distributions, topology, filters, Bachmann-Landay
notations, derivative and differentiation.

This library relies on extensionality axioms (propositional and
functional extentionality) and on classical axioms (excluded middle
and a custom version of axiom of choice). These axioms are not derived
from the standard library's axioms in the current draft. Additionally
we temporarily rely on classical reals from the Coq standard library.

There is also a small number of "Admitted" theorems in this
development version.</p><div class="metadata"><div class="authors">authors: <span class="author">Reynald Affeldt</span><span class="author">Cyril Cohen</span><span class="author">Assia Mahboubi</span><span class="author">Damien Rouhling</span><span class="author">Pierre-Yves Strub</span></div><div class="versions">version: <span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/higman-s"><h3 class="name">coq-higman-s</h3></a><p class="description">Higman's lemma on an unrestricted alphabet.

This proof is more or less the proof given by Monika Seisenberger in "An Inductive Version of Nash-Williams' Minimal-Bad-Sequence Argument for Higman's Lemma".
</p><div class="metadata"><div class="authors">author: <span class="author">William Delobel</span></div><div class="dates">date: <span class="date">2007-09-14</span><span class="date"> 2007-09-14</span></div><div class="categories">categories: <span class="category">Mathematics/Combinatorics and Graph Theory</span><span class="category"> Mathematics/Combinatorics and Graph Theory</span></div><div class="keywords">keywords: <span class="keyword">higman's lemma</span><span class="keyword">well quasi ordering</span><span class="keyword"> Higman's lemma</span><span class="keyword"> well quasi-ordering</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/lambek"><h3 class="name">coq-lambek</h3></a><p class="description">A Coq Toolkit for Lambek Calculus.

This library contains some definitions concerning Lambek calculus.
Three formalisations of this calculus are proposed, and also some certified
functions which translate derivations from one formalism to another.
Several derived properties are proved and also some meta-theorems.
Users can define their own lexicons and use the defined tactics to prove the
derivation of sentences in a particular system (L, NL, LP, NLP ...)
</p><div class="metadata"><div class="authors">authors: <span class="author">Houda Anoun</span><span class="author">Pierre Castéran</span></div><div class="dates">date: <span class="date">March-July 2003</span><span class="date"> March-July 2003</span></div><div class="categories">categories: <span class="category">Computer Science/Formal Languages Theory and Automata</span><span class="category"> Computer Science/Formal Languages Theory and Automata</span></div><div class="keywords">keywords: <span class="keyword">computational linguistic</span><span class="keyword">categorial grammar</span><span class="keyword">lambek calculus</span><span class="keyword"> Computational linguistic</span><span class="keyword"> categorial grammar</span><span class="keyword"> Lambek calculus...</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/multiplier"><h3 class="name">coq-multiplier</h3></a><p class="description">Proof of a multiplier circuit.
</p><div class="metadata"><div class="authors">author: <span class="author">Christine Paulin</span></div><div class="categories">categories: <span class="category">Computer Science/Architecture</span><span class="category">Miscellaneous/Extracted Programs/Hardware</span><span class="category"> Computer Science/Architecture</span><span class="category"> Miscellaneous/Extracted Programs/Hardware</span></div><div class="keywords">keywords: <span class="keyword">hardware verification</span><span class="keyword">circuit</span><span class="keyword"> hardware verification</span><span class="keyword"> circuit</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/thtuerk/MSetsExtra"><h3 class="name">coq-msets-extra</h3></a><p class="description">Extensions of MSets for Efficient Execution

Coq's MSet library provides various, reasonably efficient finite set
implementations. Nevertheless, FireEye was struggling with performance
issues. This library contains extensions to Coq's MSet library that
helped the FireEye Formal Methods team (formal-methods@fireeye.com),
solve these performance issues. There are

- Fold With Abort
  efficient folding with possibility to start late and stop early

- Interval Sets
  a memory efficient representation of sets of numbers
  
- Unsorted Lists with Duplicates
</p><div class="metadata"><div class="authors">authors: <span class="author">FireEye Formal Methods Team</span><span class="author">Thomas Tuerk</span></div><div class="dates">date: <span class="date">2016-10-04</span></div><div class="categories">categories: <span class="category">Computer Science/Data Types and Data Structures</span><span class="category">Miscellaneous/Extracted Programs/Data structures</span></div><div class="keywords">keywords: <span class="keyword">finite sets</span><span class="keyword">fold with abort</span><span class="keyword">extracting efficient code</span><span class="keyword">data structures</span></div><div class="versions">versions: <span class="version">1.1.0</span><span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/coinductive-reals"><h3 class="name">coq-coinductive-reals</h3></a><p class="description">Real numbers as coinductive ternary streams.

See the README file
</p><div class="metadata"><div class="authors">author: <span class="author">Milad Niqui</span></div><div class="dates">date: <span class="date">2007-04-24</span><span class="date"> 2007-04-24</span></div><div class="categories">categories: <span class="category">Mathematics/Arithmetic and Number Theory/Real numbers</span><span class="category"> Mathematics/Arithmetic and Number Theory/Real numbers</span></div><div class="keywords">keywords: <span class="keyword">real numbers</span><span class="keyword">coinductive types</span><span class="keyword">co recursion</span><span class="keyword">exact arithmetic</span><span class="keyword"> real numbers</span><span class="keyword"> co-inductive types</span><span class="keyword"> co-recursion</span><span class="keyword"> exact arithmetic</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/ptsf"><h3 class="name">coq-ptsf</h3></a><p class="description">Explicit Convertibility Proofs in Pure Type Systems.

Formalization of the proof that PTS and PTS with explicit convertibility proofs (PTSf) are equivalent.
</p><div class="metadata"><div class="authors">authors: <span class="author">Herman Geuvers</span><span class="author">Floris van Doorn</span><span class="author">Freek Wiedijk</span></div><div class="categories">category: <span class="category">Mathematics/Logic/Type theory</span></div><div class="keywords">keywords: <span class="keyword">pure type systems</span><span class="keyword">judgmental equality</span><span class="keyword">explicit equality proofs</span><span class="keyword">proof relevance</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/graph-basics"><h3 class="name">coq-graph-basics</h3></a><p class="description">a Coq toolkit for graph theory.

This library offers inductive definitions of basics
in graph theory. The goal is to offer the possibility to write proofs
and programs on graphs in the same formalism : the Coq language.
It now contains : vertices, arcs, edges, degrees, graphs, directed
graphs,
paths, acyclic graphs, connected graphs and tree.
</p><div class="metadata"><div class="authors">author: <span class="author">Jean Duprat</span></div><div class="dates">date: <span class="date">2001-04</span><span class="date"> April 2001</span></div><div class="categories">categories: <span class="category">Mathematics/Combinatorics and Graph Theory</span><span class="category"> Mathematics/Combinatorics and Graph Theory</span></div><div class="keywords">keywords: <span class="keyword">graph theory</span><span class="keyword">curry howard's isomorphism</span><span class="keyword">inductive</span><span class="keyword">definitions</span><span class="keyword"> graph theory</span><span class="keyword"> Curry-Howard's isomorphism</span><span class="keyword"> inductive definitions</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/string"><h3 class="name">coq-string</h3></a><p class="description">Definition of strings in Coq.

Strings as list of characters.
</p><div class="metadata"><div class="authors">author: <span class="author">Laurent Théry</span></div><div class="dates">date: <span class="date">2002-03</span><span class="date"> 2002-03</span></div><div class="categories">categories: <span class="category">Miscellaneous/Coq Extensions</span><span class="category"> Miscellaneous/Coq Extensions</span></div><div class="keywords">keywords: <span class="keyword">string</span><span class="keyword">ascii character</span><span class="keyword"> string</span><span class="keyword"> ascii character</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/bertrand"><h3 class="name">coq-bertrand</h3></a><p class="description">Correctness of Knuth's algorithm for prime numbers.

A proof of correctness of the algorithm as described in
`The Art of Computer Programming: Fundamental Algorithms'
by Knuth, pages 147-149
</p><div class="metadata"><div class="authors">author: <span class="author">Laurent Théry</span></div><div class="dates">date: <span class="date">2002</span><span class="date"> 2002</span></div><div class="categories">categories: <span class="category">Mathematics/Arithmetic and Number Theory/Number theory</span><span class="category">Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs based on external tools</span><span class="category">Miscellaneous/Extracted Programs/Arithmetic</span><span class="category"> Mathematics/Arithmetic and Number Theory/Number theory</span><span class="category"> Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs based on external tools</span><span class="category"> Miscellaneous/Extracted Programs/Arithmetic</span></div><div class="keywords">keywords: <span class="keyword">knuth's algorithm</span><span class="keyword">prime numbers</span><span class="keyword">bertrand's postulate</span><span class="keyword"> Knuth's algorithm</span><span class="keyword"> prime numbers</span><span class="keyword"> Bertrand's postulate</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/UniMath/UniMath"><h3 class="name">coq-unimath</h3></a><p class="description"></p><div class="metadata"><div class="authors">author: <span class="author">The UniMath Development Team</span></div><div class="versions">versions: <span class="version">8.7.dev</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/io-system"><h3 class="name">coq-io-system</h3></a><p class="description">System effects for Coq.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">versions: <span class="version">2.2.0</span><span class="version">2.4.0</span><span class="version">2.0.0</span><span class="version">2.1.0</span><span class="version">2.3.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/aa755/SquiggleEq"><h3 class="name">coq-squiggle-eq</h3></a><p class="description">A formalization of Howe's Squiggle equality
Howe, Douglas J. “Equality in Lazy Computation Systems.” In LICS, 198–203, 1989.

</p><div class="metadata"><div class="authors">authors: <span class="author">Abhishek Anand</span><span class="author">Vincent Rahli</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.0.2</span><span class="version">1.0.3</span><span class="version">1.0.1</span><span class="version">1.0.4</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/karatsuba"><h3 class="name">coq-karatsuba</h3></a><p class="description">Karatsuba's Multiplication.

An implementation of Karatsuba's Multiplication algorithm
</p><div class="metadata"><div class="authors">author: <span class="author">Russell O'Connor</span></div><div class="dates">date: <span class="date">2005-09-15</span></div><div class="categories">category: <span class="category">Mathematics/Arithmetic and Number Theory/Number theory</span></div><div class="keywords">keywords: <span class="keyword">karatsuba multiplication</span><span class="keyword">binary ring</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/zsearch-trees"><h3 class="name">coq-zsearch-trees</h3></a><p class="description">Binary Search Trees.

Algorithms for collecting, searching, inserting and deleting elements in binary search trees on nat
</p><div class="metadata"><div class="authors">author: <span class="author">Pierre Castéran</span></div><div class="categories">categories: <span class="category">Computer Science/Data Types and Data Structures</span><span class="category">Miscellaneous/Extracted Programs/Data structures</span><span class="category"> Computer Science/Data Types and Data Structures</span><span class="category"> Miscellaneous/Extracted Programs/Data structures</span></div><div class="keywords">keywords: <span class="keyword">binary search trees</span><span class="keyword"> binary search trees</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/fermat4"><h3 class="name">coq-fermat4</h3></a><p class="description">Diophantus' 20th Problem and Fermat's Last Theorem for n = 4.

This contribution presents the formalization of Fermat's proofs of
Diophantus' 20th Problem and Fermat's Last Theorem for n = 4. The proofs are
completed using Fermat's "wonderful" method of infinite descent.
</p><div class="metadata"><div class="authors">authors: <span class="author">David Delahaye</span><span class="author">Micaela Mayero</span></div><div class="dates">date: <span class="date">2005-07</span><span class="date"> 2005-07</span></div><div class="categories">categories: <span class="category">Mathematics/Arithmetic and Number Theory/Number theory</span><span class="category"> Mathematics/Arithmetic and Number Theory/Number theory</span></div><div class="keywords">keywords: <span class="keyword">diophantus</span><span class="keyword">fermat</span><span class="keyword">arithmetic</span><span class="keyword">infinite descent</span><span class="keyword"> Diophantus</span><span class="keyword"> Fermat</span><span class="keyword"> Arithmetic</span><span class="keyword"> Infinite Descent</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/vzaliva/coq-min-imports"><h3 class="name">coq-min-imports</h3></a><p class="description">This script will try to remove unnecessary module imports from Coq
sources. It examines modules listed in "Require Import" statements one
by one and tries to recompile to see if their removal would cause
compilation errors.
</p><div class="metadata"><div class="authors">author: <span class="author">Vadim Zaliva</span></div><div class="dates">date: <span class="date">2018-04-22</span></div><div class="categories">category: <span class="category">Miscellaneous/Coq Extensions</span></div><div class="versions">versions: <span class="version">1.0.1</span><span class="version">1.0.0</span><span class="version">1.0.2</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/thery/Plouffe"><h3 class="name">coq-plouffe</h3></a><p class="description">A Coq formalization of Plouffe formula.
</p><div class="metadata"><div class="versions">versions: <span class="version">dev</span><span class="version">1.1.0</span><span class="version">1.2.0</span><span class="version">1.4.0</span><span class="version">1.2.1</span><span class="version">1.0.0</span><span class="version">1.3.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://math-comp.github.io/math-comp/"><h3 class="name">coq-mathcomp-solvable</h3></a><p class="description">Mathematical Components Library on finite groups (II)

This library contains more definitions and theorems about finite groups.</p><div class="metadata"><div class="authors">authors: <span class="author">Jeremy Avigad</span><span class="author">Andrea Asperti</span><span class="author">Stephane Le Roux</span><span class="author">Yves Bertot</span><span class="author">Laurence Rideau</span><span class="author">Enrico Tassi</span><span class="author">Ioana Pasca</span><span class="author">Georges Gonthier</span><span class="author">Sidi Ould Biha</span><span class="author">Cyril Cohen</span><span class="author">Francois Garillot</span><span class="author">Alexey Solovyev</span><span class="author">Russell O'Connor</span><span class="author">Laurent Théry</span><span class="author">Assia Mahboubi</span></div><div class="keywords">keywords: <span class="keyword">finite groups</span><span class="keyword">Feit Thompson theorem</span><span class="keyword">small scale reflection</span><span class="keyword">mathematical components</span><span class="keyword">odd order theorem</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.6.1</span><span class="version">1.6.2</span><span class="version">1.7.0</span><span class="version">1.6.4</span><span class="version">1.6</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/markov"><h3 class="name">coq-markov</h3></a><p class="description">Markov's inequality.

A proof of Markov's inequality, restricted to probability spaces, based on the Wikipedia proof. Defines Lebesgue integral and associated concepts such as measurability, measure functions, and sigma algebras. Extended real numbers did not need to be defined because we are working in a probability space with measure 1. Nonconstructive; uses classic, Extensionality_Ensembles, axiomatized real numbers from Coq standard library.
</p><div class="metadata"><div class="authors">author: <span class="author">Robert Kam</span></div><div class="dates">date: <span class="date">2008-01-5</span></div><div class="categories">category: <span class="category">Mathematics/Real Calculus and Topology</span></div><div class="keywords">keywords: <span class="keyword">probability theory</span><span class="keyword">markov</span><span class="keyword">lebesgue integral</span><span class="keyword">measures</span><span class="keyword">sigma algebras</span><span class="keyword">measurability</span><span class="keyword">borel</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/kildall"><h3 class="name">coq-kildall</h3></a><p class="description">Application of the Generic kildall's Data Flow Analysis Algorithm to a Type and Shape Static Analyses of Bytecode.

This Library provides a generic data flow analysis
algorithm and a proof of its correctness.
This algorithm is then used to perform type and
shape analysis at bytecode level
on a first order functionnal language.
</p><div class="metadata"><div class="authors">authors: <span class="author">Solange Coupet-Grimal</span><span class="author">William Delobel</span></div><div class="dates">date: <span class="date">2005-07</span><span class="date"> 2005-07</span></div><div class="categories">categories: <span class="category">Computer Science/Semantics and Compilation/Semantics</span><span class="category"> Computer Science/Semantics and Compilation/Semantics</span></div><div class="keywords">keywords: <span class="keyword">kildall</span><span class="keyword">data flow analysis</span><span class="keyword">bytecode verification</span><span class="keyword"> Kildall</span><span class="keyword"> data flow analysis</span><span class="keyword"> bytecode verification</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/math-comp/multinomials-ssr"><h3 class="name">coq-mathcomp-multinomials</h3></a><p class="description">A Multinomial Library for the Mathematical Components Library.
</p><div class="metadata"><div class="authors">author: <span class="author">Pierre-Yves Strub</span></div><div class="dates">date: <span class="date">2016</span></div><div class="categories">categories: <span class="category">Math/Algebra/Multinomials</span><span class="category">Math/Algebra/Monoid algebra</span></div><div class="keywords">keywords: <span class="keyword">multinomials</span><span class="keyword">monoid algebra</span></div><div class="versions">versions: <span class="version">1.x.dev</span><span class="version">1.1</span><span class="version">dev</span><span class="version">1.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://coq.inria.fr/"><h3 class="name">coqide</h3></a><p class="description">IDE of the Coq formal proof management system.
</p><div class="metadata"><div class="versions">version: <span class="version">8.8.2</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/uwplse/verdi-raft"><h3 class="name">coq-verdi-raft</h3></a><p class="description">Verdi Raft is a verified implementation of the Raft distributed consensus protocol in Coq.
</p><div class="metadata"><div class="authors">authors: <span class="author">James Wilcox</span><span class="author">Doug Woos</span><span class="author">Pavel Panchekha</span><span class="author">Zachary Tatlock</span><span class="author">Steve Anton</span><span class="author">Karl Palmskog</span><span class="author">Ryan Doenges</span><span class="author">Justin Adsuara</span></div><div class="categories">category: <span class="category">Computer Science/Concurrent Systems and Protocols/Theory of concurrent systems</span></div><div class="keywords">keywords: <span class="keyword">program verification</span><span class="keyword">distributed algorithms</span><span class="keyword">raft</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.7.dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/rem"><h3 class="name">coq-rem</h3></a><p class="description">Rem Theorem in Baire space.

A formalisation of Rem Theorem in Baire space
</p><div class="metadata"><div class="authors">author: <span class="author">Henk Barendregt</span></div><div class="categories">category: <span class="category">Mathematics/Real Calculus and Topology</span></div><div class="keywords">keywords: <span class="keyword">rem theorem</span><span class="keyword">baire space</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/zf"><h3 class="name">coq-zf</h3></a><p class="description">An axiomatisation of intuitionistic Zermelo-Fraenkel set theory.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Alexandre</span></div><div class="categories">categories: <span class="category">Mathematics/Logic/Set theory</span><span class="category"> Mathematics/Logic/Set theory</span></div><div class="keywords">keywords: <span class="keyword">set theory</span><span class="keyword">zermelo fraenkel</span><span class="keyword"> Set Theory</span><span class="keyword"> Zermelo-Fraenkel</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/gmalecha/coq-plugin-utils"><h3 class="name">coq-plugin-utils</h3></a><p class="description">Utility functions for implementing Coq plugins, e.g. building natural
numbers, interfacing with Ltac, etc.
</p><div class="metadata"><div class="versions">versions: <span class="version">1.1.0</span><span class="version">1.2.0</span><span class="version">1.3.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://math-comp.github.io/math-comp/"><h3 class="name">coq-mathcomp-field</h3></a><p class="description">Mathematical Components Library on Fields

This library contains definitions and theorems about field extensions,
galois theory, algebraic numbers, cyclotomic polynomials...</p><div class="metadata"><div class="authors">authors: <span class="author">Jeremy Avigad</span><span class="author">Andrea Asperti</span><span class="author">Stephane Le Roux</span><span class="author">Yves Bertot</span><span class="author">Laurence Rideau</span><span class="author">Enrico Tassi</span><span class="author">Ioana Pasca</span><span class="author">Georges Gonthier</span><span class="author">Sidi Ould Biha</span><span class="author">Cyril Cohen</span><span class="author">Francois Garillot</span><span class="author">Alexey Solovyev</span><span class="author">Russell O'Connor</span><span class="author">Laurent Théry</span><span class="author">Assia Mahboubi</span></div><div class="keywords">keywords: <span class="keyword">algebra</span><span class="keyword">field</span><span class="keyword">small scale reflection</span><span class="keyword">mathematical components</span><span class="keyword">odd order theorem</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.6.4</span><span class="version">1.6</span><span class="version">1.7.0</span><span class="version">1.6.1</span><span class="version">1.6.2</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/abp"><h3 class="name">coq-propcalc</h3></a><p class="description">Propositional Calculus

Formalization of basic theorems about classical propositional logic. The main theorems are (1) the soundness and completeness of natural deduction calculus, (2) the equivalence between natural deduction calculus, Hilbert systems and sequent calculus and (3) cut elimination for sequent calculus.
Keywords: propositional calculus, classical logic, completeness, natural deduction, sequent calculus, cut elimination.
</p><div class="metadata"><div class="authors">author: <span class="author">Floris van Doorn</span></div><div class="categories">categories: <span class="category">Mathematics/Logic/Foundations</span><span class="category"> Mathematics/Logic/Foundations</span></div><div class="keywords">keywords: <span class="keyword">propositional calculus</span><span class="keyword">classical logic</span><span class="keyword">completeness</span><span class="keyword">natural deduction</span><span class="keyword">sequent calculus</span><span class="keyword">cut elimination</span><span class="keyword"> propositional calculus</span><span class="keyword"> classical logic</span><span class="keyword"> completeness</span><span class="keyword"> natural deduction</span><span class="keyword"> sequent calculus</span><span class="keyword"> cut elimination</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/goedel"><h3 class="name">coq-goedel</h3></a><p class="description">The Gödel-Rosser 1st incompleteness theorem.

A proof that any first order theory extending NN (which is PA
without induction) that is complete is inconsistent
</p><div class="metadata"><div class="authors">author: <span class="author">Russell O'Connor</span></div><div class="dates">date: <span class="date">2007-04-13</span></div><div class="categories">category: <span class="category">Mathematics/Logic/Foundations</span></div><div class="keywords">keywords: <span class="keyword">goedel</span><span class="keyword">rosser</span><span class="keyword">incompleteness</span><span class="keyword">logic</span><span class="keyword">hilbert</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://coq.inria.fr/"><h3 class="name">coq</h3></a><p class="description">Formal proof management system.
</p><div class="metadata"><div class="versions">version: <span class="version">8.8.2</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://i.imgur.com/fQpmoXE.jpg"><h3 class="name">coq-force-84</h3></a><p class="description">Force the use of Coq 8.4 versions.
</p><div class="metadata"><div class="versions">version: <span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/pedagand/coq-label"><h3 class="name">coq-label</h3></a><p class="description">'label' is a Coq plugin for referring to Propositional hypotheses by their type</p><div class="metadata"><div class="authors">authors: <span class="author">Pierre-Évariste Dagand</span><span class="author">Théo Zimmermann</span><span class="author">Pierre-Marie Pédrot</span></div><div class="versions">version: <span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://color.inria.fr/"><h3 class="name">coq-color</h3></a><p class="description">A library on rewriting theory and termination.
</p><div class="metadata"><div class="authors">authors: <span class="author">Frédéric Blanqui</span><span class="author">Adam Koprowski</span><span class="author">Sébastien Hinderer</span><span class="author">Pierre-Yves Strub</span><span class="author">Sidi Ould Biha</span><span class="author">Solange Coupet-Grimal</span><span class="author">William Delobel</span><span class="author">Hans Zantema</span><span class="author">Stéphane Leroux</span><span class="author">Léo Ducas</span><span class="author">Johannes Waldmann</span><span class="author">Qiand Wang</span><span class="author">Lianyi Zhang</span><span class="author">Sorin Stratulat</span></div><div class="dates">date: <span class="date">2017-01-11</span><span class="date">2018-05-04</span></div><div class="categories">categories: <span class="category">Computer Science/Algorithms/Correctness proofs of algorithms</span><span class="category">Computer Science/Data Types and Data Structures</span><span class="category">Computer Science/Lambda Calculi</span><span class="category">Mathematics/Algebra</span><span class="category">Mathematics/Combinatorics and Graph Theory</span><span class="category">Mathematics/Logic/Type theory</span><span class="category">Miscellaneous/Extracted Programs/Type checking unification and normalization</span></div><div class="keywords">keywords: <span class="keyword">rewriting</span><span class="keyword">termination</span><span class="keyword">lambda calculus</span><span class="keyword">list</span><span class="keyword">multiset</span><span class="keyword">polynom</span><span class="keyword">vectors</span><span class="keyword">matrices</span><span class="keyword">FSet</span><span class="keyword">FMap</span><span class="keyword">term</span><span class="keyword">context</span><span class="keyword">substitution</span><span class="keyword">universal algebra</span><span class="keyword">varyadic term</span><span class="keyword">string</span><span class="keyword">alpha-equivalence</span><span class="keyword">de bruijn indices</span><span class="keyword">simple types</span><span class="keyword">matching</span><span class="keyword">unification</span><span class="keyword">relation</span><span class="keyword">ordering</span><span class="keyword">quasi-ordering</span><span class="keyword">lexicographic ordering</span><span class="keyword">ring</span><span class="keyword">semiring</span><span class="keyword">well-founded</span><span class="keyword">noetherian</span><span class="keyword">finitely branching</span><span class="keyword">dependent choice</span><span class="keyword">infinite sequences</span><span class="keyword">non-termination</span><span class="keyword">loop</span><span class="keyword">graph</span><span class="keyword">path</span><span class="keyword">transitive closure</span><span class="keyword">strongly connected component</span><span class="keyword">topological ordering</span><span class="keyword">rpo</span><span class="keyword">horpo</span><span class="keyword">dependency pair</span><span class="keyword">dependency graph</span><span class="keyword">semantic labeling</span><span class="keyword">reducibility</span><span class="keyword">Girard</span><span class="keyword">fixpoint theorem</span><span class="keyword">Tarski</span><span class="keyword">pigeon-hole principle</span><span class="keyword">Ramsey theorem</span></div><div class="versions">versions: <span class="version">8.7.dev</span><span class="version">1.1.0</span><span class="version">1.3.0</span><span class="version">1.2.0</span><span class="version">1.4.0</span><span class="version">dev</span><span class="version">1.0.0</span><span class="version">1.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/zchinese"><h3 class="name">coq-zchinese</h3></a><p class="description">A proof of the Chinese Remainder Lemma.

OBSOLETE. See rather Zchinese-lemma that uses Z of Zarith.
</p><div class="metadata"><div class="authors">author: <span class="author">Valérie Ménissier-Morain</span></div><div class="categories">categories: <span class="category">Mathematics/Arithmetic and Number Theory/Number theory</span><span class="category">Miscellaneous/Extracted Programs/Arithmetic</span></div><div class="keywords">keywords: <span class="keyword">number theory</span><span class="keyword">chinese remainder</span><span class="keyword">primality</span><span class="keyword">prime numbers</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/smtcoq/smtcoq"><h3 class="name">coq-smtcoq</h3></a><p class="description">A tool to check proof witnesses coming from external SAT and SMT solvers and to call SAT and SMT solvers from Coq.
</p><div class="metadata"><div class="authors">authors: <span class="author">Michaël Armand</span><span class="author">Benjamin Grégoire</span><span class="author">Chantal Keller</span></div><div class="versions">version: <span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-concurrency/pluto"><h3 class="name">coq-concurrency-pluto</h3></a><p class="description">A web server written in Coq.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">versions: <span class="version">1.1.0</span><span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/firing-squad"><h3 class="name">coq-firing-squad</h3></a><p class="description">Firing Squad Synchronization Problem.

This contribution is a formal verification of a solution
of the firing squad synchronization problem.
</p><div class="metadata"><div class="authors">author: <span class="author">Jean Duprat</span></div><div class="categories">categories: <span class="category">Computer Science/Concurrent Systems and Protocols/Correctness of specific protocols</span><span class="category">Miscellaneous/Extracted Programs/Automata and protocols</span><span class="category"> Computer Science/Concurrent Systems and Protocols/Correctness of specific protocols</span><span class="category"> Miscellaneous/Extracted Programs/Automata and protocols</span></div><div class="keywords">keywords: <span class="keyword">concurrency</span><span class="keyword">synchronization</span><span class="keyword">finite state machines</span><span class="keyword"> concurrency</span><span class="keyword"> synchronization</span><span class="keyword"> finite-state machines</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/gc"><h3 class="name">coq-gc</h3></a><p class="description">Formal Verification of an Incremental Garbage Collector.

We specify an incremental garbage collection algorithm and we give a formal proof of its
correctness. The algorithm is represented as an infinite transition system and we establish safety
and liveness properties. This work relies on an axiomatization of LTL and is based on a co-inductive
representation of programs executions. Although motivated by integrating the dynamic memory
management to the Java Card platform, this study applies more generally to real-time embedded systems and to devices with virtually infinite memory.
</p><div class="metadata"><div class="authors">authors: <span class="author">Solange Coupet-Grimal</span><span class="author">Catherine Nouvet</span><span class="author">Solange Coupet-Grimal and Catherine Nouvet</span></div><div class="dates">date: <span class="date">2003-05-9</span><span class="date"> 2003-05-9</span></div><div class="categories">categories: <span class="category">Computer Science/Semantics and Compilation/Compilation</span><span class="category"> Computer Science/Semantics and Compilation/Compilation</span></div><div class="keywords">keywords: <span class="keyword">linear temporal logic</span><span class="keyword">finite sets</span><span class="keyword">coinduction</span><span class="keyword">garbage collection</span><span class="keyword"> Linear temporal logic</span><span class="keyword"> finite sets</span><span class="keyword"> co-induction</span><span class="keyword"> garbage collection</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/param-pi"><h3 class="name">coq-param-pi</h3></a><p class="description">Coding of a typed monadic pi-calculus using parameters for free names.

This development contains the specification for a monadic
pi-calculus using the same coding method for names than
J. Mc Kinna and R. Pollack used for PTS in LEGO:
"Some Lambda Calculus and Type Theory Formalized".

The basic, monadic calculus encoded here has a type system
restraining the direction of communication for processes' names.

A number of lemmas usefull for doing proofs on that coding
are included, and subject reduction properties for each kind
of transition is made as an example of actually using the
coding to mechanize proofs on the pi-calculus.
</p><div class="metadata"><div class="authors">author: <span class="author">Loïc Henry-Gréard</span></div><div class="dates">date: <span class="date">1998-09-30</span><span class="date"> 1998-09-30</span></div><div class="categories">categories: <span class="category">Computer Science/Lambda Calculi</span><span class="category"> Computer Science/Lambda Calculi</span></div><div class="keywords">keywords: <span class="keyword">pi calculus</span><span class="keyword"> Pi-Calculus</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://coquelicot.saclay.inria.fr/"><h3 class="name">coq-coquelicot</h3></a><p class="description">A Coq formalization of real analysis compatible with the standard library.
</p><div class="metadata"><div class="authors">authors: <span class="author">Sylvie Boldo</span><span class="author">Catherine Lelay</span><span class="author">Guillaume Melquiond</span></div><div class="categories">category: <span class="category">Mathematics/Real Calculus and Topology</span></div><div class="keywords">keywords: <span class="keyword">real analysis</span><span class="keyword">topology</span><span class="keyword">filters</span><span class="keyword">metric spaces</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">2.1.2</span><span class="version">2.1.0</span><span class="version">2.1.1</span><span class="version">2.0.1</span><span class="version">3.0.2</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/mini-compiler"><h3 class="name">coq-mini-compiler</h3></a><p class="description">Correctness of a tiny compiler for arithmetic expressions.

Tutorial correctness proof of a tiny compiler from
simple arithmetic expressions (constants, variables and additions) to
simple assembly-like code (one accumulator, infinitly many registers and
addition)
</p><div class="metadata"><div class="authors">author: <span class="author">Jean-Christophe Filliâtre</span></div><div class="dates">date: <span class="date">2003</span><span class="date"> 2003</span></div><div class="categories">categories: <span class="category">Computer Science/Semantics and Compilation/Compilation</span><span class="category"> Computer Science/Semantics and Compilation/Compilation</span></div><div class="keywords">keywords: <span class="keyword">compilation</span><span class="keyword">correctness</span><span class="keyword">arithmetic</span><span class="keyword"> compilation</span><span class="keyword"> correctness</span><span class="keyword"> arithmetic</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://gitlab.inria.fr/fpottier/coq-menhirlib"><h3 class="name">coq-menhirlib</h3></a><p class="description">A support library for verified Coq parsers produced by Menhir

The Menhir parser generator, in --coq mode, can produce Coq parsers.
These parsers must be linked against this library, which provides
both an interpreter (which allows running the generated parser) and
a validator (which allows verifying, at parser construction time,
that the generated parser is correct and complete with respect to
the grammar).
</p><div class="metadata"><div class="versions">versions: <span class="version">20180530</span><span class="version">20180827</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/area-method"><h3 class="name">coq-area-method</h3></a><p class="description">The Chou, Gao and Zhang area method.

This contribution is the implementation of the Chou, Gao and Zhang's area method decision procedure for euclidean plane geometry.
This development contains a partial formalization of the book "Machine Proofs in Geometry, Automated Production of Readable Proofs for Geometry Theorems" by Chou, Gao and Zhang.
The examples shown automatically (there are more than 100 examples) includes the Ceva, Desargues, Menelaus, Pascal, Centroïd, Pappus, Gauss line, Euler line, Napoleon theorems.
Changelog
2.1 : remove some not needed assumptions in some elimination lemmas (2010)
2.0 : extension implementation to Euclidean geometry (2009-2010)
1.0 : first implementation for affine geometry (2004)
</p><div class="metadata"><div class="authors">author: <span class="author">Julien Narboux</span></div><div class="dates">date: <span class="date">2004-2010</span><span class="date"> 2004-2010</span></div><div class="keywords">keywords: <span class="keyword">geometry</span><span class="keyword">chou gao zhang area method</span><span class="keyword">decision procedure</span><span class="keyword"> geometry</span><span class="keyword"> Chou Gao Zhang area method</span><span class="keyword"> decision procedure</span><span class="keyword"> automatic theorem proving</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/coq-moment"><h3 class="name">coq-moment</h3></a><p class="description">Parse, manipulate and pretty-print times and dates in Coq.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">version: <span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/constructive-geometry"><h3 class="name">coq-constructive-geometry</h3></a><p class="description">Elements of Constructive Geometry.

Constructive Geometry following Jan von Plato.
</p><div class="metadata"><div class="authors">author: <span class="author">Gilles Kahn</span></div><div class="categories">categories: <span class="category">Mathematics/Geometry/General</span><span class="category"> Mathematics/Geometry/General</span></div><div class="keywords">keywords: <span class="keyword">constructive mathematics</span><span class="keyword">geometry</span><span class="keyword"> Constructive mathematics</span><span class="keyword"> Geometry</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://software.imdea.org/fcsl/"><h3 class="name">coq-fcsl-pcm</h3></a><p class="description">Partial Commutative Monoids

The PCM library provides a formalisation of Partial Commutative Monoids (PCMs),
a common algebraic structure used in separation logic for verification of
pointer-manipulating sequential and concurrent programs.
The library provides lemmas for mechanised and automated reasoning about PCMs
in the abstract, but also supports concrete common PCM instances, such as heaps,
histories and mutexes.

This library relies on extensionality axioms: propositional and
functional extentionality.
</p><div class="metadata"><div class="authors">author: <span class="author">Aleksandar Nanevski</span></div><div class="keywords">keywords: <span class="keyword">separation logic</span><span class="keyword">partial commutative monoid</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.0.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/xavierleroy/coq2html"><h3 class="name">coq-coq2html</h3></a><p class="description">Generates HTML documentation from Coq source files.  Alternative to coqdoc.
</p><div class="metadata"><div class="versions">versions: <span class="version">1.0</span><span class="version">1.1</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/cybele"><h3 class="name">coq-cybele</h3></a><p class="description">A Coq plugin for simpler proofs by reflection or OCaml certificates.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">version: <span class="version">1.3.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://gitlab.mpi-sws.org/robbertkrebbers/coq-stdpp"><h3 class="name">coq-stdpp</h3></a><p class="description">This project contains an extended "Standard Library" for Coq called coq-std++.
The key features of this library are as follows:

- It provides a great number of definitions and lemmas for common data
  structures such as lists, finite maps, finite sets, and finite multisets.
- It uses type classes for common notations (like `∅`, `∪`, and Haskell-style
  monad notations) so that these can be overloaded for different data structures.
- It uses type classes to keep track of common properties of types, like it
  having decidable equality or being countable or finite.
- Most data structures are represented in canonical ways so that Leibniz
  equality can be used as much as possible (for example, for maps we have
  `m1 = m2` iff `∀ i, m1 !! i = m2 !! i`). On top of that, the library provides
  setoid instances for most types and operations.
- It provides various tactics for common tasks, like an ssreflect inspired
  `done` tactic for finishing trivial goals, a simple breadth-first solver
  `naive_solver`, an equality simplifier `simplify_eq`, a solver `solve_proper`
  for proving compatibility of functions with respect to relations, and a solver
  `set_solver` for goals involving set operations.
- It is entirely dependency- and axiom-free.
</p><div class="metadata"><div class="versions">versions: <span class="version">1.0.0</span><span class="version">1.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/gmalecha/mirror-core"><h3 class="name">coq-mirror-core</h3></a><p class="description">A framework for computational reflection.
</p><div class="metadata"><div class="authors">author: <span class="author">Gregory Malecha</span></div><div class="versions">versions: <span class="version">1.0.1</span><span class="version">1.0.0</span><span class="version">1.0.2</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/traversable-fincontainer"><h3 class="name">coq-traversable-fincontainer</h3></a><p class="description">A Coq proof that all Traversable functors are isomorphic to finitary containers.
</p><div class="metadata"><div class="authors">author: <span class="author">Russell O'Connor</span></div><div class="categories">categories: <span class="category">Computer Science/Data Types and Data Structures</span><span class="category"> Computer Science/Data Types and Data Structures</span></div><div class="keywords">keywords: <span class="keyword">finitary container</span><span class="keyword">traversable functor</span><span class="keyword"> finitary container</span><span class="keyword"> traversable functor</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/thery/PolTac"><h3 class="name">coq-poltac</h3></a><p class="description">A set of tactics to deal with inequalities in Coq over N, Z and R:
</p><div class="metadata"><div class="authors">author: <span class="author">Laurent Théry</span></div><div class="versions">version: <span class="version">0.8.8</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/chdoc/coq-reglang"><h3 class="name">coq-reglang</h3></a><p class="description">Regular Language Representations in the Constructive Type Theory of Coq

We verify translations between different representations of regular
languages: various forms of automata (deterministic, nondeterministic,
one-way, two-way), regular expressions, and the logic WS1S. We also
show various decidability results and closure properties.</p><div class="metadata"><div class="authors">authors: <span class="author">Christian Doczkal</span><span class="author">Gert Smolka</span></div><div class="categories">category: <span class="category">Computer Science/Formal Languages Theory and Automata</span></div><div class="keywords">keywords: <span class="keyword">regular languages</span><span class="keyword">regular expressions</span><span class="keyword">finite automata</span><span class="keyword">two-way automata</span><span class="keyword">monadic second-order logic</span></div><div class="versions">version: <span class="version">1</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/davidnowak/bellantonicook"><h3 class="name">coq-bellantonicook</h3></a><p class="description">Deep embedding of Bellantoni and Cook's syntactic characterization of polytime functions
</p><div class="metadata"><div class="authors">authors: <span class="author">Sylvain Heraud</span><span class="author">David Nowak</span></div><div class="dates">date: <span class="date">2018-09-06</span></div><div class="categories">category: <span class="category">CS/Algo/Complexity</span></div><div class="keywords">keywords: <span class="keyword">implicit complexity</span><span class="keyword">polynomial time</span></div><div class="versions">version: <span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/uwplse/cheerios"><h3 class="name">coq-cheerios</h3></a><p class="description">Cheerios is a Coq library for serialization.
</p><div class="metadata"><div class="authors">authors: <span class="author">Keith Simmons</span><span class="author">Doug Woos</span><span class="author">James Wilcox</span><span class="author">Justin Adsuara</span><span class="author">Karl Palmskog</span></div><div class="keywords">keyword: <span class="keyword">serialization</span></div><div class="versions">versions: <span class="version">8.7.dev</span><span class="version">dev</span><span class="version">8.6.dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/bollu/SCEV-coq"><h3 class="name">coq-scev</h3></a><p class="description">Scalar evolution is an algebraic theory of recurrences. It has found
use in modern compilers which use the theory to model loop variables.
This is an implementation of the scalar evolution theory in Coq. In particular,
it implements the definitions and simplification lemmas from the
original "chains of recurrences" paper.
</p><div class="metadata"><div class="authors">author: <span class="author">Siddharth Bhat</span></div><div class="dates">date: <span class="date">2016-09-01</span></div><div class="categories">category: <span class="category">Miscellaneous/Coq Extensions</span></div><div class="keywords">keyword: <span class="keyword">math</span></div><div class="versions">version: <span class="version">1.0.1</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/CertiKOS/coqrel"><h3 class="name">coq-coqrel</h3></a><p class="description">Binary logical relations library for the Coq proof assistant
</p><div class="metadata"><div class="authors">author: <span class="author">Jérémie Koenig</span></div><div class="categories">category: <span class="category">Mathematics/Logic/Type theory</span></div><div class="keywords">keyword: <span class="keyword">relations</span></div><div class="versions">version: <span class="version">0.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-ext-lib/coq-ext-lib"><h3 class="name">coq-ext-lib</h3></a><p class="description">A library of Coq definitions, theorems, and tactics.
</p><div class="metadata"><div class="authors">author: <span class="author">Gregory Malecha</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">0.9.7</span><span class="version">0.9.0~beta3</span><span class="version">0.9.1</span><span class="version">0.9.4</span><span class="version">0.9.6</span><span class="version">0.9.8</span><span class="version">0.10.0</span><span class="version">dev</span><span class="version">0.9.5</span><span class="version">0.9.2</span><span class="version">0.9.0</span><span class="version">0.9.3</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/paradoxes"><h3 class="name">coq-paradoxes</h3></a><p class="description">Paradoxes in Set Theory and Type Theory.

A formalisation of Burali-Forti paradox in system U (the
existence of an ordinal of ordinals is inconsistent), of Diaconescu
paradox (axiom of choice implies excluded-middle), of Reynolds paradox
(there is no set-theoretic model of system F) and Hurkens paradox in
system U (adapted by H. Geuvers to show the inconsistency of
Excluded-Middle in impredicative-Set Calculus of Inductive Constructions).
</p><div class="metadata"><div class="authors">authors: <span class="author">Bruno Barras</span><span class="author">Benjamin Werner</span><span class="author">Hugo Herbelin</span><span class="author">Thierry Coquand</span></div><div class="categories">category: <span class="category">Mathematics/Logic/Foundations</span></div><div class="keywords">keywords: <span class="keyword">reynolds paradox</span><span class="keyword">burali forti paradox</span><span class="keyword">diaconescu paradox</span><span class="keyword">set theory</span><span class="keyword">system u</span><span class="keyword">inconsistency</span><span class="keyword">hurkens paradox</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/descente-infinie"><h3 class="name">coq-descente-infinie</h3></a><p class="description">The Descente Infinie Tactic.

This is a tactic plugin for coq. The tactic helps to prove inductive lemmas by fixpoint functions. A manual for the tactic can be found on its homepage listed above.
</p><div class="metadata"><div class="authors">authors: <span class="author">Li Mengran</span><span class="author">Razvan Voicu</span></div><div class="dates">date: <span class="date">2010-02</span></div><div class="categories">category: <span class="category">Miscellaneous/Coq Extensions</span></div><div class="keywords">keywords: <span class="keyword">induction</span><span class="keyword">infinite descent</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/shuffle"><h3 class="name">coq-shuffle</h3></a><p class="description">Gilbreath's card trick.

A full axiomatization and proof development of a non-trivial property of binary sequences, inspired from a card trick of N. Gilbreath.
</p><div class="metadata"><div class="authors">author: <span class="author">Gérard Huet</span></div><div class="categories">categories: <span class="category">Miscellaneous/Logical Puzzles and Entertainment</span><span class="category"> Miscellaneous/Logical Puzzles and Entertainment</span></div><div class="keywords">keywords: <span class="keyword">gilbreath's card trick</span><span class="keyword">binary sequences</span><span class="keyword"> Gilbreath's card trick</span><span class="keyword"> binary sequences</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/higman-cf"><h3 class="name">coq-higman-cf</h3></a><p class="description">A direct constructive proof of Higman's Lemma.

This development formalizes in Coq the Coquand-Friedlender proof of
Higman's lemma for a two-letter alphabet.
An efficient program can be extracted from the proof.
</p><div class="metadata"><div class="authors">author: <span class="author">Stefan Berghofer</span></div><div class="categories">categories: <span class="category">Mathematics/Combinatorics and Graph Theory</span><span class="category">Miscellaneous/Extracted Programs/Combinatorics</span></div><div class="keywords">keywords: <span class="keyword">higman's lemma</span><span class="keyword">extraction</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/math-comp/bigenough"><h3 class="name">coq-mathcomp-bigenough</h3></a><p class="description">A small library to do epsilon - N reasonning.

The package contains a package to reasoning with big enough objects
(mostly natural numbers). This package is essentially for backward
compatibility purposes as `bigenough` will be subsumed by the near
tactics. The formalization is based on the Mathematical Components
library.
</p><div class="metadata"><div class="authors">author: <span class="author">Cyril Cohen</span></div><div class="keywords">keywords: <span class="keyword">bigenough</span><span class="keyword">asymptotic reasonning</span><span class="keyword">small scale reflection</span><span class="keyword">mathematical components</span></div><div class="versions">version: <span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/distributed-reference-counting"><h3 class="name">coq-distributed-reference-counting</h3></a><p class="description">A Construction of Distributed Reference Counting.

This library contains the constructive proof of correctness of
several variants of a distributed reference counting algorithm.
</p><div class="metadata"><div class="authors">authors: <span class="author">Luc Moreau</span><span class="author">Jean Duprat</span><span class="author">Luc Moreau, Jean Duprat</span></div><div class="categories">categories: <span class="category">Computer Science/Semantics and Compilation/Compilation</span><span class="category">Computer Science/Concurrent Systems and Protocols/Correctness of specific protocols</span><span class="category"> Computer Science/Semantics and Compilation/Compilation</span><span class="category"> Computer Science/Concurrent Systems and Protocols/Correctness of specific protocols</span></div><div class="keywords">keywords: <span class="keyword">garbage collection</span><span class="keyword">distributed algorithms</span><span class="keyword"> garbage collection</span><span class="keyword"> distributed algorithms</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/lukaszcz/coqhammer"><h3 class="name">coq-hammer</h3></a><p class="description">Automation for Dependent Type Theory
</p><div class="metadata"><div class="authors">authors: <span class="author">Lukasz Czajka</span><span class="author">Cezary Kaliszyk</span><span class="author">Burak Ekici</span></div><div class="dates">date: <span class="date">2018-08-22</span></div><div class="categories">category: <span class="category">Misc/Coq Extensions</span></div><div class="keywords">keyword: <span class="keyword">automation</span></div><div class="versions">versions: <span class="version">1.1+8.8</span><span class="version">1.0.9+8.8.1</span><span class="version">1.0.3</span><span class="version">1.0.8+8.7</span><span class="version">1.0.9+8.8.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://perso.crans.org/cohen/work/fpmods/"><h3 class="name">coq-fpmods</h3></a><p class="description">A short constructive formalization of finitely presented modules.
</p><div class="metadata"><div class="versions">version: <span class="version">0.2.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/UniMath/UniMath"><h3 class="name">coq-unimath-substitution-systems</h3></a><p class="description">Aims to formalize a substantial body of mathematics using the univalent point of view. 
</p><div class="metadata"><div class="authors">author: <span class="author">The UniMath Development Team</span></div><div class="versions">version: <span class="version">0.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/prfx"><h3 class="name">coq-prfx</h3></a><p class="description">Proof Reflection in Coq.

A formalisation of natural deduction for first-order
logic with explicit proof terms. Read README.
</p><div class="metadata"><div class="authors">author: <span class="author">Dimitri Hendriks</span></div><div class="dates">date: <span class="date">15 April2005</span><span class="date">2005-04-15</span></div><div class="categories">category: <span class="category">Mathematics/Logic/Foundations</span></div><div class="keywords">keywords: <span class="keyword">first order logic</span><span class="keyword">natural deduction</span><span class="keyword">reflection</span><span class="keyword">proof terms</span><span class="keyword">de bruijn indices</span><span class="keyword">permutative conversions</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/DistributedComponents/disel"><h3 class="name">coq-disel</h3></a><p class="description">Core framework files for Disel, a separation-style logic for compositional verification of distributed systems
</p><div class="metadata"><div class="authors">authors: <span class="author">Ilya Sergey</span><span class="author">James R. Wilcox</span></div><div class="dates">date: <span class="date">2018-09-21</span></div><div class="categories">category: <span class="category">Computer Science/Concurrent Systems and Protocols/Theory of concurrent systems</span></div><div class="keywords">keywords: <span class="keyword">program verification</span><span class="keyword">separation logic</span><span class="keyword">distributed algorithms</span></div><div class="versions">version: <span class="version">2.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/thery/GeometricAlgebra"><h3 class="name">coq-geometric-algebra</h3></a><p class="description">Grassman Cayley and Clifford formalisations
</p><div class="metadata"><div class="versions">version: <span class="version">0.8.8</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/llee454/functional-algebra"><h3 class="name">coq-functional-algebra</h3></a><p class="description"> This package provides a Coq formalization of abstract algebra using
 a functional programming style. The modules contained within the
 package span monoids, groups, rings, and fields and provides both
 axiom definitions for these structures and proofs of foundational
 results. The current package contains over 800 definitions and
 proofs.

This module is unique in that it eschews the tactic-oriented
style of traditional Coq developments. As pointed out by others,
programs written in that style are brittle, hard to read, and
generally inefficient.

While tactic driven development is useful for sketching out proofs,
these disadvantages should dissuade us from publising proofs in
this form.

In this library, I provide a worked example of using Gallina
directly and demonstrate both the feasibility of this approach
and its advantages in terms of clarity, maintainability, and
compile-time efficiency.

In addition, this module includes two expression simplifiers. The
first, defined in monoid_expr.v simplifies monoid expressions. The
second, defined in group_expr.v simplifies group expressions.

These functions allow us to automate many of the steps involved in
proving algebraic theorems directly in Gallina, and represent an
alternative to relying on tactics such as auto, omega, etc.

For more information about this package, please read its Readme
file, which can be found here:

https://github.com/llee454/functional-algebra.
</p><div class="metadata"><div class="authors">author: <span class="author">Larry D. Lee Jr.</span></div><div class="dates">date: <span class="date">2018-08-11</span></div><div class="categories">category: <span class="category">Miscellaneous/Coq Extensions</span></div><div class="keywords">keywords: <span class="keyword">algebra</span><span class="keyword">abstract algebra</span></div><div class="versions">version: <span class="version">1.0.2</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://www-sop.inria.fr/members/Yves.Bertot/"><h3 class="name">coq-pi-agm</h3></a><p class="description">Computing thousands or millions of digits of PI with arithmetic-geometric means

This is a proof of correctness for an algorithm to compute PI to high precision
using an algorithm based on arithmetic-geometric means.  A first file contains
the calculus-based proofs for an abstract view of the algorithm, where all
numbers are real numbers.  A second file describes how to approximate all
computations using large integers.  The whole development can be used to
produce mathematically proved and formally verified approximations of PI.
</p><div class="metadata"><div class="authors">author: <span class="author">Yves Bertot</span></div><div class="categories">category: <span class="category">Mathematics/Real Calculus and Topology</span></div><div class="keywords">keywords: <span class="keyword">real analysis</span><span class="keyword">pi</span></div><div class="versions">versions: <span class="version">1.1.0</span><span class="version">1.2.0</span><span class="version">1.2.1</span><span class="version">1.2.2</span><span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/io-exception"><h3 class="name">coq-io-exception</h3></a><p class="description">Abstract your errors into exceptions.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">versions: <span class="version">1.1.0</span><span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://i.imgur.com/fQpmoXE.jpg"><h3 class="name">coq-force-85</h3></a><p class="description">Force the use of Coq 8.5 versions.
</p><div class="metadata"><div class="versions">version: <span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/mit-plv/fiat-crypto"><h3 class="name">coq-fiat-crypto-legacy</h3></a><p class="description">Cryptographic Primitive Code Generation in Fiat (legacy pipeline).
</p><div class="metadata"><div class="authors">authors: <span class="author">Andres Erbsen</span><span class="author">Google Inc.</span><span class="author">Jade Philipoom</span><span class="author">Massachusetts Institute of Technology</span></div><div class="versions">versions: <span class="version">8.8.dev</span><span class="version">8.9.dev</span><span class="version">8.7.dev</span><span class="version">8.6.dev</span><span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/angles"><h3 class="name">coq-angles</h3></a><p class="description">Formalization of the oriented angles theory.

The basis of the contribution is a formalization of the
theory of oriented angles of non-zero vectors. Then, we prove some
classical plane geometry theorems: the theorem which gives a necessary
and sufficient condition so that four points are cocyclic, the one
which shows that the reflected points with respect to the sides of a
triangle orthocenter are on its circumscribed circle, the Simson's
theorem and the Napoleon's theorem. The reader can refer to the
associated research report (http://www-sop.inria.fr/lemme/FGRR.ps) and
the README file of the contribution.
</p><div class="metadata"><div class="authors">author: <span class="author">Frédérique Guilhot</span></div><div class="dates">date: <span class="date">2002-01-15</span></div><div class="categories">category: <span class="category">Mathematics/Geometry/General</span></div><div class="keywords">keywords: <span class="keyword">pcoq</span><span class="keyword">geometry</span><span class="keyword">plane geometry</span><span class="keyword">oriented angles</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/buchberger"><h3 class="name">coq-buchberger</h3></a><p class="description">Proof of Buchberger's algorithm.

A machine-checked implementation of Buchberger's.
It computes the Grobner basis associated to a
polynomial ideal.
</p><div class="metadata"><div class="authors">authors: <span class="author">Henrik Persson</span><span class="author">Laurent Théry</span></div><div class="dates">date: <span class="date">1998</span><span class="date"> 1998</span></div><div class="categories">categories: <span class="category">Mathematics/Algebra</span><span class="category">Miscellaneous/Extracted Programs/Combinatorics</span><span class="category"> Mathematics/Algebra</span><span class="category"> Miscellaneous/Extracted Programs/Combinatorics</span></div><div class="keywords">keywords: <span class="keyword">grobner basis</span><span class="keyword">polynomial ideal</span><span class="keyword">buchberger's algorithm</span><span class="keyword"> Grobner basis</span><span class="keyword"> polynomial ideal</span><span class="keyword"> Buchberger's algorithm</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/coq-error-handlers"><h3 class="name">coq-error-handlers</h3></a><p class="description">Simple and robust error handling functions.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">versions: <span class="version">1.0.0</span><span class="version">1.1.0</span><span class="version">1.2.0</span><span class="version">1.1.1</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/cfgv"><h3 class="name">coq-cfgv</h3></a><p class="description">Generic Proofs about Alpha Equality and Substitution.

Please read the following paper
</p><div class="metadata"><div class="authors">authors: <span class="author">Vincent Rahli</span><span class="author">Abhishek</span></div><div class="categories">category: <span class="category">Computer Science/Lambda Calculi</span></div><div class="keywords">keywords: <span class="keyword">generic programming</span><span class="keyword">variable bindings</span><span class="keyword">context free grammars</span><span class="keyword">substitution</span><span class="keyword">alpha equality</span><span class="keyword">equivariance</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/ybertot/improper_integrals"><h3 class="name">coq-improper-integrals</h3></a><p class="description">Additions to the coquelicot library for handling improper integrals

This package contains a few theorems whose use case was discovered when
making experiments, for instance in the pi-agm package.  These theorems
should probably integrated in coquelicot in the long run, but having this
package makes them easily available while waiting for any necessary cleanup
and discussion to happen.
</p><div class="metadata"><div class="authors">author: <span class="author">Yves Bertot</span></div><div class="categories">category: <span class="category">Mathematics/Real Calculus and Topology</span></div><div class="keywords">keyword: <span class="keyword">real analysis</span></div><div class="versions">version: <span class="version">0.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/tree-automata"><h3 class="name">coq-tree-automata</h3></a><p class="description">Tree automatas.

provides tree automatas algorithms in Coq (merge,
intersection, vacuity test, deletion of empty states, coaccessiblity test,
deletion of non coaccessible states)
</p><div class="metadata"><div class="authors">authors: <span class="author">Xavier Rival</span><span class="author">Xavier Rival [http://www.eleves.ens.fr/home/rival]</span></div><div class="dates">date: <span class="date">1999-09</span><span class="date"> september 1999</span></div><div class="categories">categories: <span class="category">Computer Science/Formal Languages Theory and Automata</span><span class="category"> Computer Science/Formal Languages Theory and Automata</span></div><div class="keywords">keywords: <span class="keyword">tree automatas</span><span class="keyword">bottom up reflexion terms</span><span class="keyword"> tree automatas</span><span class="keyword"> bottom up reflexion terms</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-concurrency/proxy"><h3 class="name">coq-concurrency-proxy</h3></a><p class="description">A proxy to interface concurrent Coq programs with the operating system.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">version: <span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/ltl"><h3 class="name">coq-ltl</h3></a><p class="description">Linear Temporal Logic.

This contribution contains a shallow embedding of Linear
Temporal Logic (LTL) based on a co-inductive representation of program
executions. Temporal operators are implemented as inductive
(respectively co-inductive) types when they are least (respectively
greatest) fixpoints. Several general lemmas,
that correspond to LTL rules, are proved.
</p><div class="metadata"><div class="authors">author: <span class="author">Solange Coupet-Grimal</span></div><div class="dates">date: <span class="date">2002-07</span><span class="date"> 2002-07</span></div><div class="categories">categories: <span class="category">Mathematics/Logic/Modal logic</span><span class="category"> Mathematics/Logic/Modal logic</span></div><div class="keywords">keywords: <span class="keyword">temporal logic</span><span class="keyword">infinite transition systems</span><span class="keyword">coinduction</span><span class="keyword"> temporal logic</span><span class="keyword"> infinite transition systems</span><span class="keyword"> co-induction</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://ppsimpl.gforge.inria.fr/"><h3 class="name">coq-ppsimpl</h3></a><p class="description">ppsimpl is a reflexive tactic for canonising (arithmetic) goals.

</p><div class="metadata"><div class="authors">author: <span class="author">Frédéric Besson</span></div><div class="categories">category: <span class="category">Miscellaneous/Coq Extensions</span></div><div class="keywords">keywords: <span class="keyword">integers</span><span class="keyword">arithmetic</span><span class="keyword">automation</span></div><div class="versions">versions: <span class="version">1.0.0</span><span class="version">8.8.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/ptsatr"><h3 class="name">coq-ptsatr</h3></a><p class="description">PTSATR.

Formalization of the proof that PTS and PTS with judgmental equality (PTSe) are equivalent.
With this equivalence, we are able to derive all the meta-theory of PTSe, like Pi-injectivity or Subject Reduction.
</p><div class="metadata"><div class="authors">authors: <span class="author">Vincent Siles</span><span class="author">Hugo Herbelin</span></div><div class="categories">category: <span class="category">Mathematics/Logic/Type theory</span></div><div class="keywords">keywords: <span class="keyword">pure type systems</span><span class="keyword">judgmental equality</span><span class="keyword">chruch rosser</span><span class="keyword">confluence</span><span class="keyword">subject reduction</span><span class="keyword">pi injectivity</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/jordan-curve-theorem"><h3 class="name">coq-jordan-curve-theorem</h3></a><p class="description">Hypermaps, planarity and discrete Jordan curve theorem.

Constructive formalization of the combinatorial hypermaps, characterization of the planarity, genus theorem, Euler formula, ring of faces, discrete Jordan curve theorem
</p><div class="metadata"><div class="authors">author: <span class="author">Jean-François Dufourd</span></div><div class="dates">date: <span class="date">2008</span></div><div class="categories">category: <span class="category">Mathematics/Geometry/General</span></div><div class="keywords">keywords: <span class="keyword">combinatorial hypermaps</span><span class="keyword">genus</span><span class="keyword">planarity</span><span class="keyword">euler formula</span><span class="keyword">discrete jordan curve theorem</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/coq-of-ocaml"><h3 class="name">coq-of-ocaml</h3></a><p class="description">Compile OCaml to Coq.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">versions: <span class="version">1.0.0</span><span class="version">1.1.0</span><span class="version">1.2.1</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/pts"><h3 class="name">coq-pts</h3></a><p class="description">A formalisation of Pure Type Systems.

This contrib is a formalization of Pure Type Systems. It includes most
of the basic metatheoretical properties: weakening, substitution,
subject-reduction, decidability of type-checking (for strongly normalizing
PTSs). Strengtheningis not proven here.

The kernel of a very simple proof checker is automatically generated from
the proofs. A small interface allows interacting with this kernel, making
up a standalone proof system.

The Makefile has a special target "html" that produces html files from the
sources and main.html that gives a short overview.
</p><div class="metadata"><div class="authors">author: <span class="author">Bruno Barras</span></div><div class="dates">date: <span class="date">2007-03</span><span class="date"> 2007-03</span></div><div class="categories">categories: <span class="category">Computer Science/Lambda Calculi</span><span class="category"> Computer Science/Lambda Calculi</span></div><div class="keywords">keywords: <span class="keyword">calculus of constructions</span><span class="keyword">coq</span><span class="keyword">pure type systems</span><span class="keyword">metatheory</span><span class="keyword"> calculus of constructions</span><span class="keyword"> coq</span><span class="keyword"> PTS</span><span class="keyword"> pure type systems</span><span class="keyword"> metatheory</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/uwplse/verdi"><h3 class="name">coq-verdi</h3></a><p class="description">Verdi is a framework for verification of implementations of distributed systems in Coq.
</p><div class="metadata"><div class="authors">authors: <span class="author">James Wilcox</span><span class="author">Doug Woos</span><span class="author">Pavel Panchekha</span><span class="author">Zachary Tatlock</span><span class="author">Steve Anton</span><span class="author">Karl Palmskog</span><span class="author">Ryan Doenges</span><span class="author">Justin Adsuara</span></div><div class="categories">category: <span class="category">Computer Science/Concurrent Systems and Protocols/Theory of concurrent systems</span></div><div class="keywords">keywords: <span class="keyword">program verification</span><span class="keyword">distributed algorithms</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.7.dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/smc"><h3 class="name">coq-smc</h3></a><p class="description">BDD based symbolic model checker for the modal mu-calculus.

Provides BDD algorithms, a symbolic model checker for the modal
mu-calculus based on it, together with a garbage collector
</p><div class="metadata"><div class="authors">author: <span class="author">Kumar Neeraj Verma</span></div><div class="dates">date: <span class="date">2002-11</span><span class="date"> 2002-11</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span><span class="category"> Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span></div><div class="keywords">keywords: <span class="keyword">binary decision diagrams</span><span class="keyword">classical logic</span><span class="keyword">propositional logic</span><span class="keyword">garbage collection</span><span class="keyword">modal mu calculus</span><span class="keyword">model checking</span><span class="keyword">symbolic model checking</span><span class="keyword">reflection</span><span class="keyword"> BDD</span><span class="keyword"> binary decision diagrams</span><span class="keyword"> classical logic</span><span class="keyword"> propositional logic</span><span class="keyword"> garbage collection</span><span class="keyword"> modal mu-calculus</span><span class="keyword"> model checking</span><span class="keyword"> symbolic model checking</span><span class="keyword"> reflection</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://coq-interval.gforge.inria.fr/"><h3 class="name">coq-interval</h3></a><p class="description">A Coq tactic for proving bounds on real-valued expressions automatically.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Melquiond</span></div><div class="categories">categories: <span class="category">Mathematics/Real Calculus and Topology</span><span class="category">Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span></div><div class="keywords">keywords: <span class="keyword">interval arithmetic</span><span class="keyword">decision procedure</span><span class="keyword">floating point arithmetic</span><span class="keyword">reflexive tactic</span><span class="keyword">taylor models</span></div><div class="versions">versions: <span class="version">2.2.0</span><span class="version">2.1.0</span><span class="version">2.2.1</span><span class="version">3.2.0</span><span class="version">3.3.0</span><span class="version">1.1.0</span><span class="version">2.0.0</span><span class="version">3.1.1</span><span class="version">3.4.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/chinese"><h3 class="name">coq-chinese</h3></a><p class="description">A proof of the Chinese Remainder Lemma.

This is a rewriting of the contribution chinese-lemma using Zarith
</p><div class="metadata"><div class="authors">author: <span class="author">Valérie Ménissier-Morain</span></div><div class="categories">category: <span class="category">Mathematics/Arithmetic and Number Theory/Number theory</span></div><div class="keywords">keywords: <span class="keyword">number theory</span><span class="keyword">chinese remainder</span><span class="keyword">primality</span><span class="keyword">prime numbers</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/mit-plv/bbv"><h3 class="name">coq-bbv</h3></a><p class="description">An implementation of bitvectors in Coq.
</p><div class="metadata"><div class="authors">authors: <span class="author">Tej Chajed</span><span class="author">Haogang Chen</span><span class="author">Adam Chlipala</span><span class="author">Joonwon Choi</span><span class="author">Andres Erbsen</span><span class="author">Jason Gross</span><span class="author">Samuel Gruetter</span><span class="author">Frans Kaashoek</span><span class="author">Alex Konradi</span><span class="author">Gregory Malecha</span><span class="author">Duckki Oe</span><span class="author">Murali Vijayaraghavan</span><span class="author">Nickolai Zeldovich</span><span class="author">Daniel Ziegler</span></div><div class="versions">version: <span class="version">1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/aac-tactics"><h3 class="name">coq-aac-tactics</h3></a><p class="description">AAC tactics.

This Coq plugin provides tactics for rewriting universally quantified equations, modulo associative (and possibly commutative) operators:
</p><div class="metadata"><div class="authors">authors: <span class="author">Damien Pous</span><span class="author">Thomas Braibant</span></div><div class="categories">category: <span class="category">Miscellaneous/Coq Extensions</span></div><div class="keywords">keywords: <span class="keyword">reflexive tactic</span><span class="keyword">rewriting</span><span class="keyword">rewriting modulo associativity and commutativity</span><span class="keyword">rewriting modulo ac</span><span class="keyword">decision procedure</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.8.0</span><span class="version">8.5.1</span><span class="version">8.6.1</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/cats-in-zfc"><h3 class="name">coq-cats-in-zfc</h3></a><p class="description">Category theory in ZFC.

In a ZFC-like environment augmented by reference to the
ambient type theory, we develop some basic set theory, ordinals, cardinals
and transfinite induction, and category theory including functors,
natural transformations, limits and colimits, functor categories,
and the theorem that functor_cat a b has (co)limits if b does.
</p><div class="metadata"><div class="authors">author: <span class="author">Carlos Simpson</span></div><div class="dates">date: <span class="date">2004-10-10</span><span class="date"> 2004-10-10</span></div><div class="categories">categories: <span class="category">Mathematics/Logic/Set theory</span><span class="category">Mathematics/Category Theory</span><span class="category"> Mathematics/Logic/Set theory</span><span class="category"> Mathematics/Category Theory</span></div><div class="keywords">keywords: <span class="keyword">set theory</span><span class="keyword">ordinals</span><span class="keyword">cardinals</span><span class="keyword">category theory</span><span class="keyword">functors</span><span class="keyword">natural transformation</span><span class="keyword">limit</span><span class="keyword">colimit</span><span class="keyword"> set theory</span><span class="keyword"> ordinal</span><span class="keyword"> cardinal</span><span class="keyword"> category theory</span><span class="keyword"> functor</span><span class="keyword"> natural transformation</span><span class="keyword"> limit</span><span class="keyword"> colimit</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://coqtail.sourceforge.net/?home/en"><h3 class="name">coq-coqtail</h3></a><p class="description">COQ Theorems, Abstractions and Implementations (bachelor-Level).
</p><div class="metadata"><div class="versions">version: <span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/maths"><h3 class="name">coq-maths</h3></a><p class="description">Basic mathematics.

Basic mathematics (gcd, primality, etc.) from
French ``Mathematiques Superieures'' (first year of preparation to
high schools)
</p><div class="metadata"><div class="authors">author: <span class="author">Jean-Christophe Filliâtre</span></div><div class="categories">category: <span class="category">Mathematics/Arithmetic and Number Theory/Number theory</span></div><div class="keywords">keyword: <span class="keyword">mathematics</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/abp"><h3 class="name">coq-abp</h3></a><p class="description">A verification of the alternating bit protocol expressed in CBS.
</p><div class="metadata"><div class="authors">author: <span class="author">Eduardo Giménez</span></div><div class="categories">categories: <span class="category">Computer Science/Concurrent Systems and Protocols/Correctness of specific protocols</span><span class="category"> Computer Science/Concurrent Systems and Protocols/Correctness of specific protocols</span></div><div class="keywords">keywords: <span class="keyword">alternating bit protocol</span><span class="keyword">process calculi</span><span class="keyword">reactive systems</span><span class="keyword">coinductive types</span><span class="keyword">coinduction</span><span class="keyword"> alternating bit protocol</span><span class="keyword"> process calculi</span><span class="keyword"> reactive systems</span><span class="keyword"> co-inductive types</span><span class="keyword"> co-induction</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://ssr.msr-inria.inria.fr/"><h3 class="name">coq-ssreflect</h3></a><p class="description">The Small Scale Reflection extension.
</p><div class="metadata"><div class="authors">authors: <span class="author">Jeremy Avigad</span><span class="author">Andrea Asperti</span><span class="author">Stephane Le Roux</span><span class="author">Yves Bertot</span><span class="author">Laurence Rideau</span><span class="author">Enrico Tassi</span><span class="author">Ioana Pasca</span><span class="author">Georges Gonthier</span><span class="author">Sidi Ould Biha</span><span class="author">Cyril Cohen</span><span class="author">Francois Garillot</span><span class="author">Alexey Solovyev</span><span class="author">Russell O'Connor</span><span class="author">Laurent Théry</span><span class="author">Assia Mahboubi</span></div><div class="dates">date: <span class="date">Feb 2014</span></div><div class="keywords">keywords: <span class="keyword">small scale reflection</span><span class="keyword">mathematical components</span><span class="keyword">odd order theorem</span></div><div class="versions">versions: <span class="version">1.5.0</span><span class="version">1.5.1~beta2</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/weak-up-to"><h3 class="name">coq-weak-up-to</h3></a><p class="description">New Up-to Techniques for Weak Bisimulation.

This contribution is the formalisation of a paper that appeared in
Proc. of ICALP 2005: "Up-to Techniques for Weak Bisimulation".
First we define a framework for defining up-to techniques for weak
bisimulation in a modular way. Then we prove the correctness of some
new up-to techniques, based on termination guarantees. Notably, a
generalisation of Newman's Lemma to commutation results is
established.
</p><div class="metadata"><div class="authors">author: <span class="author">Damien Pous</span></div><div class="dates">date: <span class="date">2005-02-22</span><span class="date"> 2005-02-22</span></div><div class="categories">categories: <span class="category">Computer Science/Concurrent Systems and Protocols/Theory of concurrent systems</span><span class="category"> Computer Science/Concurrent Systems and Protocols/Theory of concurrent systems</span></div><div class="keywords">keywords: <span class="keyword">weak bisimulation</span><span class="keyword">up to techniques</span><span class="keyword">termination</span><span class="keyword">commutation</span><span class="keyword">newman's lemma</span><span class="keyword"> weak bisimilarity</span><span class="keyword"> weak bisimulation</span><span class="keyword"> up-to techniques</span><span class="keyword"> termination</span><span class="keyword"> commutation</span><span class="keyword"> Newman's Lemma.</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/llee454/pigeons"><h3 class="name">coq-pigeonhole-principle</h3></a><p class="description">This library provides a stand-alone proof of the Pigeonhole
principle. The Pigeonhole principle is a fundamental theorem that
is used widely in Computer Science and Combinatorics, it asserts
that if you put n things into m containers, and n > m, then at
least one of the containers contains more than one thing.

For more information about this proof, Please read its Readme file,
which can be found here: 

https://github.com/llee454/pigeons 
</p><div class="metadata"><div class="authors">author: <span class="author">Larry D. Lee Jr.</span></div><div class="dates">date: <span class="date">2018-08-25</span></div><div class="categories">category: <span class="category">Math/Combinatorics and Graph Theory</span></div><div class="keywords">keywords: <span class="keyword">pigeon-hole principle</span><span class="keyword">mathematics</span></div><div class="versions">version: <span class="version">1.0.3</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/graphs"><h3 class="name">coq-graphs</h3></a><p class="description">Satisfiability of inequality constraints and detection of cycles with negative weight in graphs.

*******************************************************************
</p><div class="metadata"><div class="authors">author: <span class="author">Jean Goubault</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span><span class="category">Miscellaneous/Extracted Programs/Combinatorics</span></div><div class="keywords">keywords: <span class="keyword">graphs</span><span class="keyword">graph theory</span><span class="keyword">cycle detection</span><span class="keyword">paths</span><span class="keyword">constraints</span><span class="keyword">inequalities</span><span class="keyword">reflection</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/io-system-ocaml"><h3 class="name">coq-io-system-ocaml</h3></a><p class="description">Extraction to OCaml of system effects.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">versions: <span class="version">2.2.0</span><span class="version">2.1.0</span><span class="version">2.0.0</span><span class="version">2.3.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/rsa"><h3 class="name">coq-rsa</h3></a><p class="description">Correctness of RSA algorithm.

This directory contains the proof of correctness
of RSA algorithm. It contains a proof of Fermat's little theorem
</p><div class="metadata"><div class="authors">authors: <span class="author">Laurent Théry</span><span class="author">Jose C. Almeida</span></div><div class="dates">date: <span class="date">1999</span><span class="date"> 1999</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span><span class="category"> Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span></div><div class="keywords">keywords: <span class="keyword">rsa</span><span class="keyword">chinese remainder</span><span class="keyword">fermat's little theorem</span><span class="keyword"> RSA</span><span class="keyword"> Chinese remainder</span><span class="keyword"> Fermat's little theorem</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/euler-formula"><h3 class="name">coq-euler-formula</h3></a><p class="description">Hypermaps, Genus Theorem and Euler Formula.

This library formalizes the combinatorial hypermaps and their properties in a constructive way. It gives the proofs of the Genus Theorem and of the Euler Formula for the polyhedra.
</p><div class="metadata"><div class="authors">author: <span class="author">Jean-François Dufourd</span></div><div class="dates">date: <span class="date">2006-09</span></div><div class="categories">category: <span class="category">Mathematics/Geometry/General</span></div><div class="keywords">keywords: <span class="keyword">polyhedron</span><span class="keyword">hypermap</span><span class="keyword">genus</span><span class="keyword">euler formula</span><span class="keyword">assisted proofs</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/gmalecha/coq-ltac-iter"><h3 class="name">coq-ltac-iter</h3></a><p class="description">Coq plugin to iterate various collections</p><div class="metadata"><div class="versions">version: <span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://math-comp.github.io/math-comp/"><h3 class="name">coq-mathcomp-odd-order</h3></a><p class="description">Odd Order Theorem

This library contains the complete formal proof of the Odd Order
Theorem (aka Feit Thompson Theorem).
The file stripped_odd_order_theorem.v contains a proof of a self
contained statement of the odd order.</p><div class="metadata"><div class="authors">authors: <span class="author">Jeremy Avigad</span><span class="author">Andrea Asperti</span><span class="author">Stephane Le Roux</span><span class="author">Yves Bertot</span><span class="author">Laurence Rideau</span><span class="author">Enrico Tassi</span><span class="author">Ioana Pasca</span><span class="author">Georges Gonthier</span><span class="author">Sidi Ould Biha</span><span class="author">Cyril Cohen</span><span class="author">Francois Garillot</span><span class="author">Alexey Solovyev</span><span class="author">Russell O'Connor</span><span class="author">Laurent Théry</span><span class="author">Assia Mahboubi</span></div><div class="keywords">keywords: <span class="keyword">Feit Thompson theorem</span><span class="keyword">small scale reflection</span><span class="keyword">mathematical components</span><span class="keyword">odd order theorem</span><span class="keyword">finite groups</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.7.0</span><span class="version">1.6.2</span><span class="version">1.6.1</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/lc"><h3 class="name">coq-lc</h3></a><p class="description">Modules over monads and lambda-calculi.

We define a notion of module over a monad and use it to
propose a new definition (or semantics) for abstract
syntax (with binding constructions). Using our notion of
module, we build a category of `exponential' monads,
which can be understood as the category of
lambda-calculi, and prove that it has an initial object
(the pure untyped lambda-calculus).
</p><div class="metadata"><div class="authors">authors: <span class="author">André Hirschowitz</span><span class="author">Marco Maggesi</span></div><div class="dates">date: <span class="date">2008-09-9</span><span class="date"> 2006-01-12</span><span class="date"> 2008-09-9</span></div><div class="categories">categories: <span class="category">Computer Science/Lambda Calculi</span><span class="category"> Computer Science/Lambda Calculi</span></div><div class="keywords">keywords: <span class="keyword">module</span><span class="keyword">monads</span><span class="keyword">category theory</span><span class="keyword">lambda calculus</span><span class="keyword">higher order syntax</span><span class="keyword"> Module</span><span class="keyword"> Monad</span><span class="keyword"> Category</span><span class="keyword"> Lambda-calculus</span><span class="keyword"> Higher-order syntax</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/vzaliva/coq-switch"><h3 class="name">coq-switch</h3></a><p class="description">A plugin to implement functionality similar to `switch` statement in C
language.

It allows easier dispatch on several constant values of a type with
decidable equality. Given a type, boolean equality predicate, and list
of choices, it will generate (using TemplateCoq) an inductive type
with constructors, one for each of the choices, and a function mapping
values to this type.</p><div class="metadata"><div class="authors">author: <span class="author">Vadim Zaliva</span></div><div class="dates">date: <span class="date">2018-09-27</span></div><div class="categories">category: <span class="category">Miscellaneous/Coq Extensions</span></div><div class="versions">version: <span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/coqoban"><h3 class="name">coq-coqoban</h3></a><p class="description">Coqoban (Sokoban).

A Coq implementation of Sokoban, the Japanese warehouse
keepers' game
</p><div class="metadata"><div class="authors">author: <span class="author">Jasper Stein</span></div><div class="dates">date: <span class="date">2003-09-19</span><span class="date"> 2003-09-19</span></div><div class="categories">categories: <span class="category">Miscellaneous/Logical Puzzles and Entertainment</span><span class="category"> Miscellaneous/Logical Puzzles and Entertainment</span></div><div class="keywords">keywords: <span class="keyword">sokoban</span><span class="keyword">puzzles</span><span class="keyword"> Sokoban</span><span class="keyword"> puzzles</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/jesper-bengtson/ChargeCore"><h3 class="name">coq-charge-core</h3></a><p class="description">A framework of typeclasses for shallow embeddings of intuitionistic
logics. Also includes definitions for separation algebras.
</p><div class="metadata"><div class="authors">authors: <span class="author">Jesper Bengtson</span><span class="author">Gregory Malecha</span></div><div class="versions">versions: <span class="version">1.0.0</span><span class="version">1.1.0</span><span class="version">1.0.1</span><span class="version">1.2.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/UniMath/UniMath"><h3 class="name">coq-unimath-tactics</h3></a><p class="description">Aims to formalize a substantial body of mathematics using the univalent point of view. 
</p><div class="metadata"><div class="authors">author: <span class="author">The UniMath Development Team</span></div><div class="versions">version: <span class="version">0.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/hoare-tut"><h3 class="name">coq-hoare-tut</h3></a><p class="description">A Tutorial on Reflecting in Coq the generation of Hoare proof obligations.

This work is both an introduction to Hoare logic and a demo
illustrating Coq nice features. It formalizes the generation of PO
(proof obligations) in a Hoare logic for a very basic imperative
programming language. It proves the soundness and the completeness of
the PO generation both in partial and total correctness. At last, it
examplifies on a very simple example (a GCD computation) how the PO
generation can simplify concrete proofs. Coq is indeed able to compute
PO on concrete programs: we say here that the generation of proof
obligations is reflected in Coq. Technically, the PO generation is
here performed through Dijkstra's weakest-precondition calculus.
</p><div class="metadata"><div class="authors">author: <span class="author">Sylvain Boulmé</span></div><div class="dates">date: <span class="date">2007</span><span class="date"> 2007</span></div><div class="categories">categories: <span class="category">Computer Science/Semantics and Compilation/Semantics</span><span class="category"> Mathematics/Logic/See also</span><span class="category"> Computer Science/Semantics and Compilation/Semantics</span></div><div class="keywords">keywords: <span class="keyword">hoare logic</span><span class="keyword">imperative program</span><span class="keyword">weakest precondition</span><span class="keyword">reflection</span><span class="keyword"> Hoare logic</span><span class="keyword"> imperative program</span><span class="keyword"> weakest precondition</span><span class="keyword"> reflection</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/lazy-pcf"><h3 class="name">coq-lazy-pcf</h3></a><p class="description">Subject Reduction for Lazy-PCF.

An Operational Semantics of Lazy Evaluation and a Proof
of Subject Reduction
</p><div class="metadata"><div class="authors">authors: <span class="author">Amy Felty</span><span class="author">Jill Seaman</span></div><div class="categories">categories: <span class="category">Computer Science/Lambda Calculi</span><span class="category"> Computer Science/Lambda Calculi</span></div><div class="keywords">keywords: <span class="keyword">functional programming</span><span class="keyword">lazy evaluation</span><span class="keyword">operational</span><span class="keyword">semantics</span><span class="keyword">type soundness</span><span class="keyword">normal forms</span><span class="keyword"> functional programming</span><span class="keyword"> lazy evaluation</span><span class="keyword"> operational semantics</span><span class="keyword"> type soundness</span><span class="keyword"> normal forms</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/classical-realizability"><h3 class="name">coq-classical-realizability</h3></a><p class="description">Krivine's classical realizability.

The aim of this Coq library is to provide a framework for checking
proofs in Krivine's classical realizability for second-order Peano arithmetic.

It is designed to be as extensible as the original theory by Krivine and to
support on-the-fly extensions by new instructions with their evaluation
rules.
</p><div class="metadata"><div class="authors">author: <span class="author">Lionel Rieg</span></div><div class="categories">categories: <span class="category">Mathematics/Logic/Foundations</span><span class="category"> Mathematics/Logic/Foundations</span></div><div class="keywords">keywords: <span class="keyword">classical realizability</span><span class="keyword">krivine's realizability</span><span class="keyword">primitive datatype</span><span class="keyword">non determinism</span><span class="keyword">quote</span><span class="keyword">axiom of countable choice</span><span class="keyword">real numbers</span><span class="keyword"> classical realizability</span><span class="keyword"> Krivine's realizability</span><span class="keyword"> primitive datatype</span><span class="keyword"> non determinism</span><span class="keyword"> quote</span><span class="keyword"> axiom of countable choice</span><span class="keyword"> real numbers</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://softwarefoundations.cis.upenn.edu/"><h3 class="name">coq-sf-lf</h3></a><p class="description">Logical Foundations (Volume 1 of Software Foundations)

Logical Foundations, serves as the entry-point to the series. It covers functional programming, basic concepts of logic, computer-assisted theorem proving, and Coq.
</p><div class="metadata"><div class="authors">authors: <span class="author">Benjamin C. Pierce</span><span class="author">Arthur Azevedo de Amorim</span><span class="author">Chris Casinghino</span><span class="author">Marco Gaboardi</span><span class="author">Michael Greenberg</span><span class="author">Cătălin Hriţcu</span><span class="author">Vilhelm Sjöberg</span><span class="author">Brent Yorgey</span></div><div class="versions">versions: <span class="version">8.7.dev</span><span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://math-comp.github.io/math-comp/"><h3 class="name">coq-mathcomp-character</h3></a><p class="description">Mathematical Components Library on character theory

This library contains definitions and theorems about group
representations, characters and class functions.</p><div class="metadata"><div class="authors">authors: <span class="author">Jeremy Avigad</span><span class="author">Andrea Asperti</span><span class="author">Stephane Le Roux</span><span class="author">Yves Bertot</span><span class="author">Laurence Rideau</span><span class="author">Enrico Tassi</span><span class="author">Ioana Pasca</span><span class="author">Georges Gonthier</span><span class="author">Sidi Ould Biha</span><span class="author">Cyril Cohen</span><span class="author">Francois Garillot</span><span class="author">Alexey Solovyev</span><span class="author">Russell O'Connor</span><span class="author">Laurent Théry</span><span class="author">Assia Mahboubi</span></div><div class="keywords">keywords: <span class="keyword">algebra</span><span class="keyword">character</span><span class="keyword">small scale reflection</span><span class="keyword">mathematical components</span><span class="keyword">odd order theorem</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.7.0</span><span class="version">1.6.2</span><span class="version">1.6.4</span><span class="version">1.6.1</span><span class="version">1.6</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/fairisle"><h3 class="name">coq-fairisle</h3></a><p class="description">Proof of the Fairisle 4x4 Switch Element .

This library contains the development of general definitions dedicated
to the verification of sequential synchronous devices (based on Moore and Mealy automata)
and the formal verification of the Fairisle 4x4 Switch Element.
</p><div class="metadata"><div class="authors">authors: <span class="author">Solange Coupet-Grimal</span><span class="author">Line Jakubiec-Jamet</span></div><div class="dates">date: <span class="date">2005-12-15</span><span class="date"> 2005-12-15</span></div><div class="categories">categories: <span class="category">Computer Science/Architecture</span><span class="category"> Computer Science/Architecture</span></div><div class="keywords">keywords: <span class="keyword">circuits</span><span class="keyword">automata</span><span class="keyword">coinduction</span><span class="keyword">dependent types</span><span class="keyword"> circuits</span><span class="keyword"> automata</span><span class="keyword"> co-induction</span><span class="keyword"> dependent types.</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/coq-iterable"><h3 class="name">coq-iterable</h3></a><p class="description">Generic definition of iterators.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">version: <span class="version">1.0.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/UniMath/UniMath"><h3 class="name">coq-unimath-ktheory</h3></a><p class="description">Aims to formalize a substantial body of mathematics using the univalent point of view. 
</p><div class="metadata"><div class="authors">author: <span class="author">The UniMath Development Team</span></div><div class="versions">version: <span class="version">0.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/lesniewski-mereology"><h3 class="name">coq-lesniewski-mereology</h3></a><p class="description">KDTL.

LesniewskiMereology is a Coq library created by R. Dapoigny and P. Barlatier whose purpose is to implement the alternative to Set Theory of Stanislaw Lesniewski. It is part of an on-going project using the Coq language and called KDTL (Knowledge-based Dependently Typed Language) to build an alternative to Description Logics. The developed theory is close to the analysis of Denis Mieville (1984) in his book "Un developpement des systemes logiques de Stanislaw Lesniewski". It is a theoretical construct which relies on three dependent levels, logic (a.k.a. Protothetic), the Lesniewski Ontologie (LO) and mereology. Each level incorporates a minimal collection of axioms, protothetic and ontologic definitions and a set of theorems together with their intuitionist proofs.
</p><div class="metadata"><div class="authors">authors: <span class="author">Patrick Barlatier</span><span class="author">Richard Dapoigny</span></div><div class="categories">categories: <span class="category">Mathematics/Logic/Foundations</span><span class="category"> Mathematics/Logic/Foundations</span></div><div class="keywords">keywords: <span class="keyword">mereology</span><span class="keyword">protothetic</span><span class="keyword">ontology</span><span class="keyword">nominalist theory</span><span class="keyword">extensionality</span><span class="keyword"> mereology</span><span class="keyword"> protothetic</span><span class="keyword"> ontology</span><span class="keyword"> nominalist theory</span><span class="keyword"> extensionality</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/abp"><h3 class="name">coq-tarski-geometry</h3></a><p class="description">Tarski's geometry

This is a formalization of geometry using a simplified version of Tarski's axiom system. The development contains a formalization of the chapters 1-8 of the book "Metamathematische Methoden in der Geometrie" by W. Schwabhäuser, W. Szmielew and A. Tarski.
This includes between properties, congruence properties, 
  midpoint, perpendicular lines, point reflection, orthogonality ...
This development aims to be a low level complement for Frédérique Guilhot's development about high-school geometry.

For more information see:
Mechanical Theorem Proving in Tarski's geometry in the post-proceeding of ADG 2006, F. Botana and T. Recio (Eds.), LNAI 4869, pages 139-156, 2007.
</p><div class="metadata"><div class="authors">author: <span class="author">Julien Narboux</span></div><div class="dates">date: <span class="date"> 2006-03</span></div><div class="categories">categories: <span class="category">Mathematics/Geometry/General</span><span class="category"> Mathematics/Geometry/General</span></div><div class="keywords">keywords: <span class="keyword">geometry</span><span class="keyword">Tarski's geometry</span><span class="keyword">congruence</span><span class="keyword">between property</span><span class="keyword">orthogonality</span><span class="keyword"> geometry</span><span class="keyword"> Tarski's geometry</span><span class="keyword"> congruence</span><span class="keyword"> between property</span><span class="keyword"> orthogonality</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.5.0</span><span class="version">8.7.0</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/free-groups"><h3 class="name">coq-free-groups</h3></a><p class="description">Free Groups.

This small contribution is a formalization of van der Waerden's proof of the construction of a free group on a set of generators, as the reduced words where a letter is a generator or its formal inverse.
</p><div class="metadata"><div class="authors">author: <span class="author">Daniel Schepler</span></div><div class="categories">category: <span class="category">Mathematics/Algebra</span></div><div class="keywords">keyword: <span class="keyword">free group</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/finger-tree"><h3 class="name">coq-finger-tree</h3></a><p class="description">Dependent Finger Trees.

A verified generic implementation of Finger Trees
</p><div class="metadata"><div class="authors">author: <span class="author">Matthieu Sozeau</span></div><div class="dates">date: <span class="date">2009-02</span></div><div class="categories">category: <span class="category">Computer Science/Data Types and Data Structures</span></div><div class="keywords">keywords: <span class="keyword">data structures</span><span class="keyword">dependent types</span><span class="keyword">finger trees</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/float"><h3 class="name">coq-float</h3></a><p class="description">Library for floating point numbers.

A library for floating point numbers.
</p><div class="metadata"><div class="authors">authors: <span class="author">Sylvie Boldo</span><span class="author">Laurent Théry</span></div><div class="dates">date: <span class="date">2001</span><span class="date"> 2001</span></div><div class="categories">categories: <span class="category">Computer Science/Data Types and Data Structures</span><span class="category"> Computer Science/Data Types and Data Structures</span></div><div class="keywords">keywords: <span class="keyword">floating point arithmetic</span><span class="keyword"> floating point arithmetic</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/ppedrot/ll-coq"><h3 class="name">coq-phase-semantics</h3></a><p class="description"> Some Coq formalizations of Linear Logic.
</p><div class="metadata"><div class="versions">version: <span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/mit-plv/fiat-crypto"><h3 class="name">coq-fiat-crypto</h3></a><p class="description">Cryptographic Primitive Code Generation in Fiat.
</p><div class="metadata"><div class="authors">authors: <span class="author">Andres Erbsen</span><span class="author">Google Inc.</span><span class="author">Jade Philipoom</span><span class="author">Massachusetts Institute of Technology</span></div><div class="versions">versions: <span class="version">8.7.dev</span><span class="version">8.9.dev</span><span class="version">dev</span><span class="version">8.8.dev</span><span class="version">8.6.dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/mattam82/Russell"><h3 class="name">coq-russell</h3></a><p class="description">Russell Metatheoretic Study.

This development prove subject reduction of the Russell language (CC with prop, set and coercion of subset types) using the TPOSR machinery. This includes an equivalence of judgmental and definitional presentations of the system.
</p><div class="metadata"><div class="authors">author: <span class="author">Matthieu Sozeau</span></div><div class="categories">categories: <span class="category">Miscellaneous/Coq Extensions</span><span class="category">Computer Science/Lambda Calculi</span></div><div class="keywords">keyword: <span class="keyword">metatheory</span></div><div class="versions">version: <span class="version">8.5.dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/axiomatic-abp"><h3 class="name">coq-axiomatic-abp</h3></a><p class="description">Verification of an axiomatisation of the Alternating Bit Protocol.

The Alternating Bit Protocol is expressed in an axiomatized calculi of process.
Correctness is proven.
</p><div class="metadata"><div class="authors">author: <span class="author">Jan Friso Groote</span></div><div class="categories">categories: <span class="category">Computer Science/Concurrent Systems and Protocols/Correctness of specific protocols</span><span class="category"> Computer Science/Concurrent Systems and Protocols/Correctness of specific protocols</span></div><div class="keywords">keywords: <span class="keyword">alternating bit protocol</span><span class="keyword">process calculi</span><span class="keyword">reactive systems</span><span class="keyword"> Alternating Bit Protocol</span><span class="keyword"> Process Calculi</span><span class="keyword"> reactive systems</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/dep-map"><h3 class="name">coq-dep-map</h3></a><p class="description">Demos of some Coq tools appeared in version V6.0.

Example of sorting algorithms defined using the Cases
(pattern-matching) construction. Demo of the decision tactic Tauto for
intuitionistic propositional calculus. Demo of the AutoRewrite tactic. Demo of
the Prolog tactic applied to the compilation of miniML programs.
</p><div class="metadata"><div class="authors">author: <span class="author">Lionel Rieg</span></div><div class="categories">category: <span class="category"> Computer Science/Data Types and Data Structures</span></div><div class="keywords">keywords: <span class="keyword"> Maps</span><span class="keyword"> Dependent maps</span><span class="keyword"> domain</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://flocq.gforge.inria.fr/"><h3 class="name">coq-flocq</h3></a><p class="description">A floating-point formalization for the Coq system.
</p><div class="metadata"><div class="authors">authors: <span class="author">Sylvie Boldo</span><span class="author">Guillaume Melquiond</span></div><div class="keywords">keyword: <span class="keyword">floating point arithmetic</span></div><div class="versions">versions: <span class="version">8.7.dev</span><span class="version">2.5.2</span><span class="version">2.3.0</span><span class="version">2.6.1</span><span class="version">2.4.0</span><span class="version">dev</span><span class="version">2.2.0</span><span class="version">3.0.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/lambda"><h3 class="name">coq-lambda</h3></a><p class="description">Residual Theory in Lambda-Calculus.

We present the complete development in Gallina of the
residual theory of beta-reduction in pure lambda-calculus. The main
result is the Prism Theorem, and its corollary Lévy's Cube Lemma, a
strong form of the parallel-moves lemma, itself a key step towards the
confluence theorem and its usual corollaries (Church-Rosser,
uniqueness of normal forms).
</p><div class="metadata"><div class="authors">author: <span class="author">Gérard Huet</span></div><div class="categories">category: <span class="category">Computer Science/Lambda Calculi</span></div><div class="keywords">keywords: <span class="keyword">pure lambda calculus</span><span class="keyword">confluence</span><span class="keyword">parallel moves lemma</span><span class="keyword">lévy's cube lemma</span><span class="keyword">church rosser</span><span class="keyword">residual</span><span class="keyword">prism theorem</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/artart78/coq-bits/"><h3 class="name">coq-bits</h3></a><p class="description">A formalization of bitset operations in Coq and the corresponding axiomatization and extraction to OCaml native integers.
</p><div class="metadata"><div class="authors">authors: <span class="author">Andrew Kennedy</span><span class="author">Arthur Blot</span><span class="author">Pierre-Évariste Dagand</span></div><div class="versions">version: <span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/matrices"><h3 class="name">coq-matrices</h3></a><p class="description">Ring properties for square matrices .

This contribution contains an operational formalization of square matrices.
(m,n)-Matrices are represented as vectors of length n. Each vector
(a row) is itself a vector whose length is m.
Vectors are actually implemented as dependent lists.

We define basic operations for this datatype (addition, product, neutral
elements O_n and I_n). We then prove the ring properties for these
operations. The development uses Coq modules to specify the interface
(the ring structure properties) as a signature.

This development deals with dependent types and partial functions.
Most of the functions are defined by dependent case analysis
and some functions such as getting a column require
the use of preconditions (to check whether we are within the
bounds of the matrix).
</p><div class="metadata"><div class="authors">author: <span class="author">Nicolas Magaud</span></div><div class="dates">date: <span class="date">2003-03</span><span class="date"> 2003-03</span></div><div class="categories">categories: <span class="category">Mathematics/Algebra</span><span class="category"> Mathematics/Algebra</span></div><div class="keywords">keywords: <span class="keyword">matrices</span><span class="keyword">vectors</span><span class="keyword">linear algebra</span><span class="keyword">coq modules</span><span class="keyword"> matrices</span><span class="keyword"> vectors</span><span class="keyword"> linear algebra</span><span class="keyword"> Coq modules</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://math-comp.github.io/math-comp/"><h3 class="name">coq-mathcomp-real-closed</h3></a><p class="description">Mathematical Components Library on real closed fields

This library contains definitions and theorems about real closed
fields, with a construction of the real closure and the algebraic
closure (including a proof of the fundamental theorem of algebra). It
also contains a proof of decidability of the first order theory of
real closed field, through quantifier elimination.
</p><div class="metadata"><div class="authors">authors: <span class="author">Jeremy Avigad</span><span class="author">Andrea Asperti</span><span class="author">Stephane Le Roux</span><span class="author">Yves Bertot</span><span class="author">Laurence Rideau</span><span class="author">Enrico Tassi</span><span class="author">Ioana Pasca</span><span class="author">Georges Gonthier</span><span class="author">Sidi Ould Biha</span><span class="author">Cyril Cohen</span><span class="author">Francois Garillot</span><span class="author">Alexey Solovyev</span><span class="author">Russell O'Connor</span><span class="author">Laurent Théry</span><span class="author">Assia Mahboubi</span></div><div class="keywords">keywords: <span class="keyword">real closed field</span><span class="keyword">Feit Thompson theorem</span><span class="keyword">small scale reflection</span><span class="keyword">mathematical components</span><span class="keyword">odd order theorem</span></div><div class="versions">version: <span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/ppedrot/ltac2"><h3 class="name">coq-ltac2</h3></a><p class="description">A tactic language for Coq.
</p><div class="metadata"><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.dev</span><span class="version">0.1-8.7</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/unicoq/"><h3 class="name">coq-unicoq</h3></a><p class="description">An enhanced unification algorithm for Coq.
</p><div class="metadata"><div class="authors">authors: <span class="author">Beta Ziliani</span><span class="author">Matthieu Sozeau</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.3+8.6</span><span class="version">1.3+8.7</span><span class="version">1.0.0</span><span class="version">1.3+8.8</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/presburger"><h3 class="name">coq-presburger</h3></a><p class="description">Presburger's algorithm.

A formalization of Presburger's algorithm as stated in
the initial paper by Presburger.
</p><div class="metadata"><div class="authors">author: <span class="author">Laurent Théry</span></div><div class="dates">date: <span class="date">2002-03</span></div><div class="categories">categories: <span class="category">Mathematics/Logic/Foundations</span><span class="category">Mathematics/Arithmetic and Number Theory/Miscellaneous</span><span class="category">Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span></div><div class="keywords">keywords: <span class="keyword">integers</span><span class="keyword">arithmetic</span><span class="keyword">decision procedure</span><span class="keyword">presburger</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/atbr"><h3 class="name">coq-atbr</h3></a><p class="description">A tactic for deciding Kleene algebras.

This library provides algebraic tools for working with
binary relations. The main tactic we provide is a reflexive tactic for
solving (in)equations in an arbitrary Kleene algebra. The decision
procedure goes through standard finite automata constructions, that we
formalized.
</p><div class="metadata"><div class="authors">authors: <span class="author">Damien Pous</span><span class="author">Thomas Braibant</span></div><div class="dates">date: <span class="date">2009-06</span><span class="date"> 2009-06</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span><span class="category"> Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span></div><div class="keywords">keywords: <span class="keyword">kleene algebra</span><span class="keyword">finite automata</span><span class="keyword">semiring</span><span class="keyword">matrices</span><span class="keyword">decision procedure</span><span class="keyword">reflexive tactic</span><span class="keyword"> Kleene algebra</span><span class="keyword"> finite automata</span><span class="keyword"> semiring</span><span class="keyword"> matrices</span><span class="keyword"> decision procedures</span><span class="keyword"> reflexive tactic</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/clarus/coq-list-string"><h3 class="name">coq-list-string</h3></a><p class="description">Strings implemented as lists.
</p><div class="metadata"><div class="authors">author: <span class="author">Guillaume Claret</span></div><div class="versions">versions: <span class="version">2.1.0</span><span class="version">1.0.0</span><span class="version">2.0.0</span><span class="version">2.1.1</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/miniml"><h3 class="name">coq-miniml</h3></a><p class="description">Correctness of the compilation of Mini-ML into the Categorical Abstract Machine.

A formalisation of Mini-ML and of the Categorical
Abstract Machine (C.A.M) in natural semantics. It also contains the
definition of the translation from Mini-ML to the CAM and the proof
that this translation is correct
</p><div class="metadata"><div class="authors">author: <span class="author">Samuel Boutin</span></div><div class="categories">category: <span class="category">Computer Science/Semantics and Compilation/Compilation</span></div><div class="keywords">keywords: <span class="keyword">functional programming</span><span class="keyword">categorical abstract machine</span><span class="keyword">compilation</span><span class="keyword">natural semantics</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/corn"><h3 class="name">coq-corn</h3></a><p class="description">Constructive Coq Repository at Nijmegen.

The Constructive Coq Repository at Nijmegen, C-CoRN, aims at building
a computer based library of constructive mathematics, formalized in
the theorem prover Coq. It includes the following parts:

* Algebraic Hierarchy

o An axiomatic formalization of the most common algebraic
structures, including setoids, monoids, groups, rings,
fields, ordered fields, rings of polynomials, real and
complex numbers

* Model of the Real Numbers

o Construction of a concrete real number structure
satisfying the previously defined axioms

* Fundamental Theorem of Algebra

o A proof that every non-constant polynomial on the complex
plane has at least one root

* Real Calculus

o A collection of elementary results on real analysis,
including continuity, differentiability, integration,
Taylor's theorem and the Fundamental Theorem of Calculus
</p><div class="metadata"><div class="authors">authors: <span class="author">Iris Loeb</span><span class="author">Rik van Ginneken</span><span class="author">Randy Pollack</span><span class="author">Mariusz Giero</span><span class="author">Dan Synek</span><span class="author">Lionel Mamane</span><span class="author">Luís Cruz-Filipe</span><span class="author">Milad Niqui</span><span class="author">Pierre Letouzey</span><span class="author">Herman Geuvers</span><span class="author">Freek Wiedijk</span><span class="author">Henk Barendregt</span><span class="author">Dimitri Hendriks</span><span class="author">Bart Kirkels</span><span class="author">Russell O'Connor</span><span class="author">Bas Spitters</span><span class="author">Sébastien Hinderer</span><span class="author">Nickolay V. Shmyrev</span><span class="author">Jan Zwanenburg</span></div><div class="categories">categories: <span class="category">Mathematics/Algebra</span><span class="category">Mathematics/Real Calculus and Topology</span></div><div class="keywords">keywords: <span class="keyword">constructive mathematics</span><span class="keyword">algebra</span><span class="keyword">real calculus</span><span class="keyword">real numbers</span><span class="keyword">fundamental theorem of algebra</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.0.0</span><span class="version">1.1.0</span><span class="version">1.2.0</span><span class="version">8.7.dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.8.1</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/groups"><h3 class="name">coq-groups</h3></a><p class="description">An exercise on groups.
</p><div class="metadata"><div class="authors">author: <span class="author">Pierre Castéran</span></div><div class="categories">category: <span class="category">Miscellaneous/Coq Use Examples</span></div><div class="keywords">keyword: <span class="keyword">group theory</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/qarith-stern-brocot"><h3 class="name">coq-qarith-stern-brocot</h3></a><p class="description">Binary Rational Numbers.

Developement of rational numbers as finite binary lists and defining field operations on them in two different ways: strict and lazy.
</p><div class="metadata"><div class="authors">authors: <span class="author">Milad Niqui</span><span class="author">Yves Bertot</span></div><div class="dates">date: <span class="date">2003</span><span class="date"> 2003</span></div><div class="categories">categories: <span class="category">Mathematics/Arithmetic and Number Theory/Rational numbers</span><span class="category">Miscellaneous/Extracted Programs/Arithmetic</span><span class="category"> Mathematics/Arithmetic and Number Theory/Rational numbers</span><span class="category"> Miscellaneous/Extracted Programs/Arithmetic</span></div><div class="keywords">keywords: <span class="keyword">rational numbers</span><span class="keyword">arithmetic</span><span class="keyword">field tactic</span><span class="keyword">binary lists</span><span class="keyword">stern brocot</span><span class="keyword"> rational numbers</span><span class="keyword"> arithmetic</span><span class="keyword"> field tactic</span><span class="keyword"> binary lists</span><span class="keyword"> Stern-Brocot</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.6.dev</span><span class="version">8.5.dev</span><span class="version">8.4.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/mutual-exclusion"><h3 class="name">coq-mutual-exclusion</h3></a><p class="description">A certification of Peterson's algorithm for managing mutual exclusion.

This is a proof of certification of Peterson's algorithm
for managing mutual exclusion. The case of two processes is treated
in the directory called ``binary'' (see the README file in this
directory). The case of n processes will be available soon.
</p><div class="metadata"><div class="authors">author: <span class="author">Eduardo Giménez</span></div><div class="categories">categories: <span class="category">Computer Science/Concurrent Systems and Protocols/Correctness of specific protocols</span><span class="category">Miscellaneous/Extracted Programs/Automata and protocols</span><span class="category"> Computer Science/Concurrent Systems and Protocols/Correctness of specific protocols</span><span class="category"> Miscellaneous/Extracted Programs/Automata and protocols</span></div><div class="keywords">keywords: <span class="keyword">mutual exclusion</span><span class="keyword">concurrency</span><span class="keyword">peterson's algorithm</span><span class="keyword">coinductive types</span><span class="keyword">coinduction</span><span class="keyword"> mutual exclusion</span><span class="keyword"> concurrency</span><span class="keyword"> Peterson's algorithm</span><span class="keyword"> co-inductive types</span><span class="keyword"> co-induction</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/pocklington"><h3 class="name">coq-pocklington</h3></a><p class="description">Pocklington's criterion.

Pocklington's criterion for checking primality for
large natural numbers. Includes a proof of Fermat's
little theorem.
</p><div class="metadata"><div class="authors">authors: <span class="author">Martijn Oostdijk</span><span class="author">Olga Caprotti</span></div><div class="dates">date: <span class="date">2000-11</span><span class="date"> 2000-11</span></div><div class="categories">categories: <span class="category">Mathematics/Arithmetic and Number Theory/Number theory</span><span class="category"> Mathematics/Arithmetic and Number Theory/Number theory</span></div><div class="keywords">keywords: <span class="keyword">pocklington</span><span class="keyword">number theory</span><span class="keyword">prime numbers</span><span class="keyword">primality</span><span class="keyword">fermat's little theorem</span><span class="keyword"> pocklington</span><span class="keyword"> number theory</span><span class="keyword"> prime numbers</span><span class="keyword"> primality</span><span class="keyword"> fermat's little theorem</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.6.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/zfc"><h3 class="name">coq-zfc</h3></a><p class="description">An encoding of Zermelo-Fraenkel Set Theory in Coq.

The encoding of Zermelo-Fraenkel Set Theory is largely inspired by
Peter Aczel's work dating back to the eighties. A type Ens is defined,
which represents sets. Two predicates IN and EQ stand for membership
and extensional equality between sets. The axioms of ZFC are then
proved and thus appear as theorems in the development.

A main motivation for this work is the comparison of the respective
expressive power of Coq and ZFC.

A non-computational type-theoretical axiom of choice is necessary to
prove the replacement schemata and the set-theoretical AC.

The main difference between this work and Peter Aczel's is that
propositions are defined on the impredicative level Prop. Since the
definition of Ens is, however, still unchanged, I also added most of
Peter Aczel's definition. The main advantage of Aczel's approach is a
more constructive vision of the existential quantifier (which gives
the set-theoretical axiom of choice for free).
</p><div class="metadata"><div class="authors">author: <span class="author">Benjamin Werner</span></div><div class="categories">category: <span class="category">Mathematics/Logic/Set theory</span></div><div class="keywords">keywords: <span class="keyword">set theory</span><span class="keyword">zermelo fraenkel</span><span class="keyword">calculus of inductive constructions</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">dev</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/UniMath/UniMath"><h3 class="name">coq-unimath-dedekind</h3></a><p class="description">Aims to formalize a substantial body of mathematics using the univalent point of view. 
</p><div class="metadata"><div class="authors">author: <span class="author">The UniMath Development Team</span></div><div class="versions">version: <span class="version">0.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/hedges"><h3 class="name">coq-hedges</h3></a><p class="description">Some properties of hedges used by hedged bisimulation.

These properties are in section 6.1 of the paper
"On Bisimulations for the Spi-Calculus" by J. Borgström
and U. Nestmann.
However, we consider here an extended message language.
</p><div class="metadata"><div class="authors">author: <span class="author">Sébastien Briais</span></div><div class="dates">date: <span class="date">2004-04-20</span></div><div class="categories">category: <span class="category">Computer Science/Concurrent Systems and Protocols/Theory of concurrent systems</span></div><div class="keywords">keywords: <span class="keyword">bisimulation</span><span class="keyword">spi calculus</span><span class="keyword">hedges</span></div><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/higman-nw"><h3 class="name">coq-higman-nw</h3></a><p class="description">A program from an A-translated impredicative proof of Higman's Lemma.

The file Higman.v formalizes an A-translated version of
Nash-Williams impredicative and classical proof of Higman's lemma
for a two-letter alphabet.
A constructive and impredicative program can be extracted from the proof.
</p><div class="metadata"><div class="authors">author: <span class="author">Hugo Herbelin</span></div><div class="categories">categories: <span class="category">Mathematics/Combinatorics and Graph Theory</span><span class="category">Miscellaneous/Extracted Programs/Combinatorics</span><span class="category"> Mathematics/Logic/See also</span><span class="category"> Mathematics/Combinatorics and Graph Theory</span><span class="category"> Miscellaneous/Extracted Programs/Combinatorics</span></div><div class="keywords">keywords: <span class="keyword">a translation</span><span class="keyword">higman's lemma</span><span class="keyword">impredicativity</span><span class="keyword">system f</span><span class="keyword">extraction</span><span class="keyword"> A-translation</span><span class="keyword"> Higman's Lemma</span><span class="keyword"> Impredicativity</span><span class="keyword"> System F</span><span class="keyword"> Extraction</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.7.0</span><span class="version">8.5.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.6.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/tree-diameter"><h3 class="name">coq-tree-diameter</h3></a><p class="description">Diameter of a binary tree.

This contribution contains the verification of a divide-and-conquer
algorithm to compute the diameter of a binary tree (the
maxmimal distance between two nodes in the tree).
</p><div class="metadata"><div class="authors">author: <span class="author">Jean-Christophe Filliâtre</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span><span class="category"> Computer Science/Decision Procedures and Certified Algorithms/Correctness proofs of algorithms</span></div><div class="keywords">keywords: <span class="keyword">program verification</span><span class="keyword">trees</span><span class="keyword">paths</span><span class="keyword">graphs</span><span class="keyword">distance</span><span class="keyword">diameter</span><span class="keyword"> program verification</span><span class="keyword"> trees</span><span class="keyword"> paths</span><span class="keyword"> graphs</span><span class="keyword"> distance</span><span class="keyword"> diameter</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://coq.inria.fr/"><h3 class="name">coq-coqide</h3></a><p class="description">IDE of the Coq formal proof management system.
</p><div class="metadata"><div class="versions">versions: <span class="version">8.5.dev</span><span class="version">8.5~rc1</span><span class="version">8.5~beta1</span><span class="version">8.6.dev</span><span class="version">8.5~beta3</span><span class="version">8.6~beta1</span><span class="version">8.7+beta1</span><span class="version">dev</span><span class="version">8.5~beta2</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/mit-plv/fiat"><h3 class="name">coq-fiat</h3></a><p class="description">Coq library for synthesizing efficient correct-by-construction programs from declarative specifications.
</p><div class="metadata"><div class="versions">version: <span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/stalmarck"><h3 class="name">coq-stalmarck</h3></a><p class="description">Proof of Stalmarck's algorithm.

A two-level approach to prove tautology
using Stalmarck's algorithm.
</p><div class="metadata"><div class="authors">authors: <span class="author">Laurent Théry</span><span class="author">Pierre Letouzey</span></div><div class="dates">date: <span class="date">2000</span></div><div class="categories">categories: <span class="category">Computer Science/Decision Procedures and Certified Algorithms/Decision procedures</span><span class="category">Miscellaneous/Extracted Programs/Decision procedures</span></div><div class="keywords">keywords: <span class="keyword">boolean formula</span><span class="keyword">tautology checker</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.7.0</span><span class="version">8.6.0</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.4.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/DeepSpec/InteractionTrees"><h3 class="name">coq-itree</h3></a><p class="description">Formalization of the Interaction Tree Datatype in Coq
</p><div class="metadata"><div class="authors">authors: <span class="author">Li-yao Xia</span><span class="author">Gregory Malecha</span><span class="author">Steve Zdancewic</span></div><div class="versions">version: <span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/relation-extraction"><h3 class="name">coq-relation-extraction</h3></a><p class="description">Functions extraction from inductive relations.

This plugin introduces a new set of extraction commands that
generates functional code form inductive specifications.
</p><div class="metadata"><div class="authors">authors: <span class="author">Catherine Dubois</span><span class="author">David Delahaye</span><span class="author">Pierre-Nicolas Tollitte</span><span class="author">Catherine Dubois, David Delahaye, Pierre-Nicolas Tollitte</span></div><div class="dates">date: <span class="date">2011</span><span class="date"> 2011</span></div><div class="categories">categories: <span class="category">Computer Science/Semantics and Compilation/Compilation</span><span class="category"> Computer Science/Semantics and Compilation/Compilation</span></div><div class="keywords">keywords: <span class="keyword">extraction</span><span class="keyword">inductive relations</span><span class="keyword">semantics</span><span class="keyword"> extraction</span><span class="keyword"> inductive relations</span><span class="keyword"> semantics</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/arthuraa/extructures"><h3 class="name">coq-extructures</h3></a><p class="description">Finite data structures with extensional reasoning.
</p><div class="metadata"><div class="authors">author: <span class="author">Arthur Azevedo de Amorim</span></div><div class="dates">date: <span class="date">2018-04-26</span></div><div class="categories">category: <span class="category">Computer Science/Data Types and Data Structures</span></div><div class="keywords">keywords: <span class="keyword">finite maps</span><span class="keyword">extensionality</span></div><div class="versions">version: <span class="version">0.1.0</span></div><div class="suites">suite: <span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/thery/grobner"><h3 class="name">coq-mathcomp-grobner</h3></a><p class="description"># grobner
A fornalisation of Grobner basis in ssreflect.
It contains one file

grobner.v

It defines.

From mathcomp Require Import all_ssreflect all_algebra.
From SsrMultinomials Require Import ssrcomplements poset freeg mpoly.
From mathcomp.contrib.grobner Require Import grobner.

(* p belongs to the ideal generated by L *)

Check ideal.

ideal = 
fun (R : ringType) (n : nat) (L : seq {mpoly R[n]}) (p : {mpoly R[n]})
  =>
  exists t, p = \sum_(i < size L) t`_i * L`_i


(* it is decidable *)

Check idealfP.

idealfP
     : forall (R : fieldType)  (n : nat) (p : {mpoly R[n]})
              (l : seq {mpoly R[n]}),
       reflect (ideal l p) (idealf l p)

</p><div class="metadata"><div class="versions">version: <span class="version">dev</span></div><div class="suites">suite: <span class="suite">extra-dev</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/izf"><h3 class="name">coq-izf</h3></a><p class="description">Intuitionistic Zermelo-Fraenkel Set Theory in Coq.

This development contains the set-as-pointed-graph
interpretation of Intuitionistic Zermelo Frankel set theory in system
F_omega.2++ (F_omega + one extra universe + intuitionistic choice
operator), which is described in chapter 9 of the author's PhD
thesis (for IZ) and in the author's CSL'03 paper (for the extension
IZ -> IZF).
</p><div class="metadata"><div class="authors">author: <span class="author">Alexandre Miquel</span></div><div class="categories">category: <span class="category">Mathematics/Logic/Set theory</span></div><div class="keywords">keywords: <span class="keyword">intuitionistic set theory</span><span class="keyword">pointed graphs</span><span class="keyword">type theory</span><span class="keyword">intuitionistic choice operator</span><span class="keyword">set theory</span><span class="keyword">zermelo fraenkel</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">8.6.0</span><span class="version">8.7.0</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">8.4.dev</span><span class="version">8.5.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/ramsey"><h3 class="name">coq-ramsey</h3></a><p class="description">Ramsey Theory.

For dimension one, the Infinite Ramsey Theorem states that, for any
subset A of the natural numbers nat, either A or nat\A is
infinite. This special case of the Pigeon Hole Principle is
classically equivalent to: if A and B are both co-finite, then so is
their intersection. None of these principles is constructively
valid. In [VB] the notion of an almost full set is introduced,
classically equivalent to co-finiteness, for which closure under
finite intersection can be proved constructively. A is almost full if
for every (strictly) increasing sequence f: nat -> nat there exists an
x in nat such that f(x) in A. The notion of almost full and its
closure under finite intersection are generalized to all finite
dimensions, yielding constructive Ramsey Theorems. The proofs for
dimension two and higher essentially use Brouwer's Bar Theorem.

In the proof development below we strengthen the notion of almost full
for dimension one in the following sense. A: nat -> Prop is called
Y-full if for every (strictly) increasing sequence f: nat -> nat we
have (A (f (Y f))). Here of course Y : (nat -> nat) -> nat. Given
YA-full A and YB-full B we construct X from YA and YB such that the
intersection of A and B is X-full. This is essentially [VB, Th. 5.4],
but now it can be done without using axioms, using only inductive
types. The generalization to higher dimensions will be much more
difficult and is not pursued here.
</p><div class="metadata"><div class="authors">author: <span class="author">Marc Bezem</span></div><div class="categories">categories: <span class="category">Mathematics/Combinatorics and Graph Theory</span><span class="category">Miscellaneous/Extracted Programs/Combinatorics</span><span class="category"> Mathematics/Logic/See also</span><span class="category"> Mathematics/Combinatorics and Graph Theory</span><span class="category"> Miscellaneous/Extracted Programs/Combinatorics</span></div><div class="keywords">keywords: <span class="keyword">dimension one ramsey theorem</span><span class="keyword">constructive mathematics</span><span class="keyword">almost full sets</span><span class="keyword"> dimension one Ramsey theorem</span><span class="keyword"> constructive mathematics</span><span class="keyword"> almost full sets</span></div><div class="versions">versions: <span class="version">8.4.dev</span><span class="version">8.5.0</span><span class="version">8.6.0</span><span class="version">8.5.dev</span><span class="version">8.6.dev</span><span class="version">dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="https://github.com/coq-contribs/ieee754"><h3 class="name">coq-ieee754</h3></a><p class="description">A formalisation of the IEEE754 norm on floating-point arithmetic.

The IEEE754 norm was born in 1985 and is now used in all
microprocessors. Here is a full formalistion in Coq of this norm,
including denormalized numbers, infinite values and NaNs.

This work can be used as a basis for
specification and proof of floating-point algorithms, e.g. to compute
the exponential. Another exciting topic would be to relate that work
to the axiomatization of real numbers of Micela Mayero, since this
formalization do not use real numbers.

See http://www.lri.fr/~loisel/rapport-stage-dea.ps.gz for a complete
discussion (in french) of this work.
</p><div class="metadata"><div class="authors">author: <span class="author">Patrick Loiseleur</span></div><div class="dates">date: <span class="date"> 1997</span></div><div class="categories">categories: <span class="category">Computer Science/Data Types and Data Structures</span><span class="category">Computer Science/Semantics and Compilation/Semantics</span><span class="category"> Computer Science/Data Types and Data Structures</span><span class="category"> Computer Science/Semantics and Compilation/Semantics</span></div><div class="keywords">keywords: <span class="keyword">floating point arithmetic</span><span class="keyword"> floating-point arithmetic</span><span class="keyword"> floats</span><span class="keyword"> IEEE</span></div><div class="versions">versions: <span class="version">8.6.dev</span><span class="version">8.6.0</span><span class="version">8.5.0</span><span class="version">8.4.dev</span><span class="version">8.5.dev</span><span class="version">dev</span><span class="version">8.7.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr>  <tr class="package"><td> <a href="http://plv.mpi-sws.org/mtac"><h3 class="name">coq-mtac</h3></a><p class="description">Mtac as a Plugin: Typed Tactics for Coq .
</p><div class="metadata"><div class="authors">author: <span class="author">Beta Ziliani</span></div><div class="versions">versions: <span class="version">dev</span><span class="version">1.3.0</span></div><div class="suites">suites: <span class="suite">extra-dev</span><span class="suite">released</span></div></div></div> </td></tr> 
  </tbody>
  </table>
  </div>

</div>

<script src="filter.js"/></script>
<script>filter_init();</script>



</div><!-- /content -->
</div><!-- /node -->
</div><!-- /content -->
<div id="sidebar-wrapper">
  <div id="sidebar">
    <div id="block-block-3" class="clear-block block block-block">
      <div class="content">
        <a href="/rss.xml">
          <img src="/files/feed.png" alt="Syndicate content"
          title="Syndicate content" width="16" height="16"
          style="position:relative; top:5px" />&nbsp; Syndicate
        </a>
      </div>
    </div>
  </div><!-- /sidebar -->
</div><!-- /sidebar-wrapper -->

</div><!-- /container -->

<div id="footer">
  <div id="nav-footer">
    <ul class="links-menu-footer">
      <li><a href="mailto:coq-www@NOSPAM@inria.fr">webmaster</a></li>
      <li><a href="http://validator.w3.org/">xhtml valid</a></li>
      <li><a href="http://jigsaw.w3.org/css-validator/">CSS valid</a></li>
    </ul>
  </div>
</div><!-- /footer -->

</body>
</html>

